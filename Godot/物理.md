<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [物理](#物理)
  - [碰撞物体](#碰撞物体)
    - [Area2D](#area2d)
    - [StaticBody2D](#staticbody2d)
    - [RigidBody2D](#rigidbody2d)
    - [CharacterBody2D](#characterbody2d)
  - [物理材质](#物理材质)
  - [碰撞形状](#碰撞形状)
  - [碰撞层与遮罩](#碰撞层与遮罩)
  - [射线](#射线)

<!-- /code_chunk_output -->

# 物理

## 碰撞物体

### Area2D

Area2D 节点提供 检测 和 影响 . 它们可以检测物体何时重叠, 并在物体进入或离开时发出信号. Area2D 也可用于覆盖物理属性, 例如一定区域内的重力或阻尼.默认情况下,area还会接收鼠标和触摸屏输入.

- 覆盖给定区域中的物理参数（例如重力）。
- 检测其他实体何时进入或退出某个区域或当前哪个实体位于某个区域。
- 检查是否与其他区域重叠。

### StaticBody2D

静态主体是物理引擎不移动的主体. 它参与碰撞检测, 但不会响应碰撞而移动. 它们通常用于属于环境的对象或不需要任何动态行为的对象.

- 平台（包括可移动的平台）
- 输送带
- 墙壁和其他障碍

### RigidBody2D

这是实现模拟2D物理的节点. 你不直接控制 RigidBody2D , 而是你对它施加力(重力, 冲动等), 物理引擎计算得到的运动.

- 使用刚体的一个好处是，可以“免费”获得许多行为而无需编写任何代码。
- 堆叠、下降、弹跳将由物理引擎自动计算。

### CharacterBody2D

提供碰撞检测的物体, 但没有物理特性. 所有移动和碰撞响应必须在代码中实现.

- 使用 move_and_collide() 或 move_and_slide() 方法
  - move_and_collide() 返回一个 KinematicCollision2D 对象, 其中包含有关碰撞和碰撞体的信息. 你可以使用此信息来确定响应.
  - move_and_slide() 提供了一种快捷方法来实现滑动且无需编写太多代码.
- 发生碰撞后，必须手动编写对碰撞的响应逻辑。

## 物理材质

静态体和刚性体可以配置为使用 物理材质 。这允许调整物体的摩擦和弹性，并设置是否具有吸收性、粗糙性。

## 碰撞形状

物理体可以包含任意数量的 Shape2D 对象作为子对象. 这些形状用于定义对象的碰撞边界并检测与其他对象的接触.

- CollisionShape2D
- CollisionPolygon2D

## 碰撞层与遮罩

- collision_layer 表示该对象位于哪些层。默认情况下，所有实体都在图层 1 上。
- collision_mask 表示该对象会对哪些层上的实体进行扫描。如果对象不在任何遮罩层中，则该实体将其忽略。默认情况下，所有实体都会扫描图层 1。

## 射线

- 节点方式：使用 RayCast2D 或 RayCast3D 节点，适合每帧都要检测的简单逻辑（如地板检测）。
- 代码方式：PhysicsServer2D

```goscript
var space_rid = get_world_2d().space
var space_state = PhysicsServer2D.space_get_direct_state(space_rid)
var query = PhysicsRayQueryParameters2D.create(Vector2(0, 88), Vector2(5000, 100))
var result = space_state.intersect_ray(query)
if !result.is_empty() and result.collider:
    print(result.collider)
```
