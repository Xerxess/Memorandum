<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [信号](#信号)
  - [连接信号](#连接信号)
  - [自定义信号demo](#自定义信号demo)

<!-- /code_chunk_output -->

# 信号

- 信号是从对象中发出消息的工具，其他对象可以对该信号做出反应。
- 要为一个类创建自定义信号，使用 signal 关键字。
- 信号是一种回调机制，同时还充当观察者的角色，这是一种常见的编程模式。
- 按照惯例，回调方法在 GDScript 中命名为“_on_node_name_signal_name”，在 C# 中命名为“OnNodeNameSignalName”。

```gdscript
extends Node

signal health_changed(new_value: int) # 定义带类型提示的信号

func take_damage(amount):
    health -= amount
    health_changed.emit(health) # 2026年推荐用法：直接调用信号对象
```

## 连接信号

- Godot 4 引入了基于 Callable 的连接方式，提供更好的重构支持和编译时检查。
  - 直接连接：信号.connect(目标函数)3
  - 带参数连接：使用 .bind() 传递额外数据。

```gdscript
# 3.*的写法
func _ready():
    var character_node = get_node('Character')
    character_node.connect("health_depleted", self, "_on_Character_health_depleted")

func _on_Character_health_depleted():
    get_tree().reload_current_scene()
```

```gdscript
# 4.*的写法
func _ready():
    var character_node = get_node('Character')
    character_node.health_depleted.connect(_on_Character_health_depleted)

func _on_Character_health_depleted():
    get_tree().reload_current_scene()
```

## 自定义信号demo

```gdscript
extends Node2D

# 声明信号。
signal health_depleted

# 声明一个或多个参数 信号。
signal health_changed(old_value, new_value)

var health = 10

func take_damage(amount):
    health -= amount
    if health <= 0:
        health_depleted.emit() # 通过代码发出信号，调用信号的 emit() 方法

func take_damage_change(amount):
    var old_health = health
    health -= amount
    health_changed.emit(old_health, health)
```
