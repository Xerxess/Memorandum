# 比较Kafka

RabbitMQ 像是一个智能的邮递员：它专注于将消息准确、安全地送到指定的人手中，处理复杂的路由逻辑。
Kafka 像是一个巨大的流水线日志本：它专注于以极快的速度记录所有发生的事情，并让下游系统按需批量读取。

## 本质区别

- RabbitMQ (推模式 - Push):
  - 机制： Broker（服务端）记录每个消费者的状态，一旦有消息，就主动推给消费者。
  - 优缺点： 延迟极低，实时性强。但如果消费者处理慢，Broker 需要维护复杂的队列状态和背压（Backpressure），容易导致 Broker 内存溢出或崩溃。
- Kafka (拉模式 - Pull):
  - 机制： 消息像日志文件一样顺序写入磁盘。消费者根据自己的速度，主动去 Kafka 询问并拉取数据（请求 Offset）。
  - 优缺点： 极高的吞吐量。Broker 很“傻”，不关心谁读到了哪里，只管写磁盘。这让它能轻松处理海量数据，且不会被慢消费者拖垮。

## 路由能力

- RabbitMQ 拥有 Exchange (交换机) 和 Binding Key (绑定键)。支持非常复杂的路由：Direct（直连）、Topic（通配符匹配）、Fanout（广播）、Header（头匹配）。
- Kafka 只有 Topic (主题) 和 Partition (分区)。 路由逻辑很简单：要么无序轮询，要么根据 Key 的 Hash 值去固定的分区。

## 消息留存与回溯

- RabbitMQ
  - 消息一旦被 Ack（确认），通常会立即从队列中删除。
  - 不支持回溯： 如果消费者处理逻辑写错了，导致数据丢失，很难重新消费旧数据（除非消息没被 Ack 且设置了死信队列）。
- Kafka
  - 消息会被持久化存储几天甚至更久
  - 支持回溯： 消费者可以随时重置 Offset（偏移量），重新读取几天前的数据。这对于数据恢复、实时计算的重跑非常关键。

## 吞吐量与性能

- RabbitMQ 万级/秒
- Kafka 十万甚至百万级/秒

## 消息顺序性

- RabbitMQ 在同一个 Queue 内，消息是先进先出（FIFO），有序。 一旦使用了多个消费者并发消费同一个 Queue，顺序就无法保证（除非设置极为严格的并发限制）。
- Kafka 在同一个 Partition 内，消息是有序的。
