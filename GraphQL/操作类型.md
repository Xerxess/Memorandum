<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [操作类型](#操作类型)
  - [查询 (queries)](#查询-queries)
    - [Fields 字段](#fields-字段)
    - [Arguments 参数](#arguments-参数)
    - [Operation type and name 操作类型和名称](#operation-type-and-name-操作类型和名称)
    - [Aliases 别名](#aliases-别名)
    - [Variables 变量](#variables-变量)
    - [Fragments 可重用单元](#fragments-可重用单元)
    - [Directives 指令](#directives-指令)
  - [Mutations 突变](#mutations-突变)
    - [Add new data 添加新数据](#add-new-data-添加新数据)
    - [Update existing data 更新现有数据](#update-existing-data-更新现有数据)
    - [Remove existing data 删除现有数据](#remove-existing-data-删除现有数据)
  - [Subscriptions 订阅](#subscriptions-订阅)
    - [Subscribing to updates 订阅更新](#subscribing-to-updates-订阅更新)
  - [Validation 验证](#validation-验证)
  - [Execution 执行](#execution-执行)
  - [Response 回复](#response-回复)
    - [Data 数据](#data-数据)
    - [Errors 错误](#errors-错误)
  - [Introspection 内省](#introspection-内省)

<!-- /code_chunk_output -->

# 操作类型

从 GraphQL 服务器获取数据

- GraphQL 支持三种主要操作类型：
  - 查询 (queries)
  - 变更 (mutation)
  - 订阅 (subscribe)

## 查询 (queries)

### Fields 字段

```
type Query {
  hero: Character
}
```

### Arguments 参数

- GraphQL 中，每个字段和嵌套对象都可以拥有自己的一组参数，这使得 GraphQL 完全可以替代多次 API 请求

```
type Query {
  human(id: ID!): Human
}
```

### Operation type and name 操作类型和名称

- 操作类型可以是 query 、 mutation 或 subscription ，用于描述您打算执行的操作类型。

```
query HeroNameAndFriends {
  hero {
    name
    friends {
      name
    }
  }
}
```

### Aliases 别名

- 别名的作用:允许你将字段的结果重命名为任何你想要的名称。

```
query {
  empireHero: hero(episode: EMPIRE) {
    name
  }
  jediHero: hero(episode: JEDI) {
    name
  }
}



```

### Variables 变量

GraphQL 提供了一种便捷的方式，将动态值从查询中分离出来，并作为单独的字典传递。这些值被称为变量

- 要使用变量，必须在 GraphQL 文档中指定操作类型和名称。
- 三件事
  - 查询中的静态值替换为 $variableName
  - 将 $variableName 声明为查询可接受的变量之一
  - 将 variableName: value 到单独的、特定于传输方式（通常为 JSON）的变量字典中

```
query HeroNameAndFriends($episode: Episode) {
  hero(episode: $episode) {
    name
    friends {
      name
    }
  }
}

# Default variables 默认变量
query HeroNameAndFriends($episode: Episode = JEDI) {
  hero(episode: $episode) {
    name
    friends {
      name
    }
  }
}
```

### Fragments 可重用单元

```
query noFragments {
  user(id: 4) {
    friends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
    mutualFriends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
  }
}
```

```
query withFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

"Common fields for a user's friends."
fragment friendFields on User {
  id
  name
  profilePic(size: 50)
}
```

### Directives 指令

- 利用变量动态地改变查询的结构和形式
- @include(if: Boolean) 仅当参数为 true 时才将此字段包含在结果中。
- @skip(if: Boolean) 如果参数为 true 则跳过此字段。

```
query Hero($episode: Episode, $withFriends: Boolean!) {
  hero(episode: $episode) {
    name
    friends @include(if: $withFriends) {
      name
    }
  }
}

```

## Mutations 突变

- 修改服务器端数据

### Add new data 添加新数据

```
enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}
 
input ReviewInput {
  stars: Int!
  commentary: String
}
 
type Mutation {
  createReview(episode: Episode, review: ReviewInput!): Review
}
```

### Update existing data 更新现有数据

```
type Mutation {
  updateHumanName(id: ID!, name: String!): Human
}
```

### Remove existing data 删除现有数据

```
type Mutation {
  deleteStarship(id: ID!): ID!
}
```

## Subscriptions 订阅

- GraphQL 规范还描述了如何通过长生命周期请求接收实时更新
- GraphQL 订阅通常由单独的发布/订阅系统支持，以便在运行时根据需要发布有关更新数据的消息，然后由 API 中订阅字段的解析器函数使用这些消息。
- GraphQL 没有指定使用哪种传输协议，因此由服务器决定。在实践中，经常使用 WebSocket 或服务器发送事件来实现。想要发送订阅操作的客户端也需要支持所选协议。目前已有社区维护的规范，用于使用 WebSocket 和服务器发送事件来实现 GraphQL 订阅。

### Subscribing to updates 订阅更新

```
type Subscription {
  reviewCreated: Review
}
```

## Validation 验证

## Execution 执行

- GraphQL 操作的执行阶段，该阶段会根据客户端请求的字段，从现有数据源读取数据或向其写入数据。
- GraphQL 查询中的每个字段看作是前一种类型的函数或方法，它会返回后一种类型的值。GraphQL 的工作原理正是如此——每种类型的每个字段都由 GraphQL 服务器开发者编写的解析器函数支持。

## Response 回复

### Data 数据

- 执行 GraphQL 请求时，响应会通过顶级 data 键返回

### Errors 错误

## Introspection 内省

- 自省查询是一种特殊的查询，它可以帮助您了解 GraphQL API 的模式，同时也能为 GraphQL 开发工具提供支持
