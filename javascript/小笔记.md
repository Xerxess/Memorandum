<!-- TOC -->

- [\<input type="checkbox|radio"\> 使用label时，会触发 input click事件](#\input-typecheckboxradio\-使用label时会触发-input-click事件)
- [iphone(一些国外手机) html5 拍照 90度换转](#iphone一些国外手机-html5-拍照-90度换转)
- [H5本地存储大小说明](#h5本地存储大小说明)
- [激活全屏模式](#激活全屏模式)
- [DOMContentLoaded](#domcontentloaded)
- [drag 原生](#drag-原生)
- [浮点数据运算类](#浮点数据运算类)
- [本地下载txt，svg等在客户端保存文件](#本地下载txtsvg等在客户端保存文件)
- [定义 getters 与 setters](#定义-getters-与-setters)
- [前端常用加密](#前端常用加密)
- [async await](#async-await)
- [url '='](#url-)

<!-- /TOC -->

# \<input type="checkbox|radio"\> 使用label时，会触发 input click事件

```html
<div id="aa">
    <input type="radio" id="abc">
    <label for="abc">abc</label>
</div>

<script>
 aa.onclick=function(event){
        console.log(event);
}
</script>
```

# iphone(一些国外手机) html5 拍照 90度换转

https://en.wikipedia.org/wiki/Exif

https://github.com/exif-js/exif-js

https://github.com/stomita/ios-imagefile-megapixel/blob/master/src/megapix-image.js



```
Camera settings. This includes static information such as the camera model and make, and information that varies with each image such as orientation (rotation), aperture, shutter speed, focal length, metering mode, and ISO speed information.

相机设置。这包括静态信息，如相机型号和品牌，以及随每个图像变化的信息，如方向（旋转），光圈，快门速度，焦距，测光模式和ISO感光度信息。
```
Orientation:方向（旋转）
https://www.impulseadventure.com/photo/exif-orientation.html  

原因
* ios 图片中的exif信息中 存在 Orientation 来表示拍摄角度。
* 图片经过处理后，Orientation 丢失，导致因该旋转的没有旋转，即图片与看到的不一至。

解决方案（可能失效）：  
* 读取exif信息进行处理  
https://github.com/exif-js/exif-js

> 补充说明

* 在chrome v81 中图片存在Orientation时进行canvas压缩时，由于new image()渲染忽略Orientation，导致处理失败;
* 在手机端，new image()的渲染是根据Orientation进行渲染，处理时可正常旋转;

```js
let img = new Image();
// window.document.body.appendChild(img)
// console.log({
//   image: img
// })
img.onload = () => {
  that.elImage = img
  // 获取图片元数据（EXIF 变量是引入的 exif-js 库暴露的全局变量）
  EXIF.getData(img, function() {
    // 获取图片旋转标志位
    EXIF.getData(img, function() {
      // var orientation = EXIF.getTag(img, 'Orientation')
      var allMetaData = EXIF.getAllTags(this);
      var orientation = allMetaData.Orientation

      // iphone 没有ImageWidth & ImageHeight
      const metaData = {
        orientation: orientation,
        ImageWidth: allMetaData.PixelXDimension || allMetaData.ImageWidth,
        ImageHeight: allMetaData.PixelYDimension || allMetaData.ImageHeight
      }

      let width = img.width
      let height = img.height

      // 处理pc与手机的差异性，根据拍摄角度宽>高
      if (orientation === 1) { // 不进行旋转
        if (img.width < img.height && metaData.ImageWidth > metaData.ImageHeight) {
          width = metaData.ImageHeight
          height = metaData.ImageWidth
        }
      }

      // 处理pc与手机的差异性，根据拍摄角度宽<高
      if (orientation === 6) { // 不进行旋转
        width = metaData.ImageWidth
        height = metaData.ImageHeight
        if (img.width < img.height) {
          width = img.width
          height = img.height
          orientation = 1
        }
      }
     
      allMetaData = null
      // 等比缩放
      const scale = width / height
      if (scale > 1) {
        height = height * (that.scaleWidth / width)
        width = that.scaleWidth
      } else {
        width = width * (that.scaleHeight / height)
        height = that.scaleHeight
      }
      that.canvas.width = width
      that.canvas.height = height

      // 根据旋转角度，在画布上对图片进行旋转
      if ((orientation === 3 || orientation === 6 || orientation === 8)) {
        switch (orientation) {
          case 3: // 旋转180°
            that.canvasGetImageData(
              res.tempFilePaths[0],
              that.canvas.width,
              that.canvas.height,
              that.canvas.width,
              that.canvas.height,
              Math.PI,
              1
            );
            break;
          case 6: // 旋转90°
            that.canvasGetImageData(res.tempFilePaths[0], that.canvas.height, 0, that.canvas
              .height,
              that.canvas.width,
              (90 * Math.PI) / 180, -1);
            break;
          case 8: // 旋转-90°
            that.canvasGetImageData(res.tempFilePaths[0], 0,that.canvas.width,that.canvas.height, that.canvas.width,
              (-90 * Math.PI) / 180, -1);
            break;
        }
      } else {
        that.canvasGetImageData(res.tempFilePaths[0], 0, 0, that.canvas.width, that.canvas.height);
      }
    })
  })
}
img.src = res.tempFilePaths[0]
```

# H5本地存储大小说明

> cookie
  * 4k
> localStorage
* chrome：5M=5012KB;
* IE11：首次打开3180KB；
* firefox：5M；
* iPhone > 2M + 512 = 2.5M;
* android 2M;

# 激活全屏模式

 https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API/Guide

 ```
var elem = document.getElementById("myvideo");
if (elem.requestFullscreen) {
  elem.requestFullscreen();
}
 ```

 # 进行一些简单操作 execCommand

https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand

https://codepen.io/chrisdavidmills/full/gzYjag/

# DOMContentLoaded

* 最初的HTML文档已被完全加载和分析，而无需等待样式表，图片事件触发，和帧完成加载。
* load应该仅用于检测完全加载的页面

# drag 原生

https://developer.mozilla.org/en-US/docs/Web/API/Document/drag_event

# 浮点数据运算类

```js
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

# 本地下载txt，svg等在客户端保存文件

* 小数据量可使用FileSaver.js
* StreamSaver.js是在客户端保存流的解决方案。它非常适合需要保存客户端创建的大量数据的webapp，其中RAM非常有限，就像在移动设备上一样。


# 定义 getters 与 setters

* 可以为预定义的或用户定义的对象定义 getter 和 setter 以支持新增的属性
* Object.defineProperty(obj,key,{get,set})
* Object.defineProperties(obj,{key:{get,set}})

```js
var o = {
  a: 7,
  get b() { 
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2
  }
};

console.log(o.a); // 7
console.log(o.b); // 8
o.c = 50;
console.log(o.a); // 25
```

# 前端常用加密

* crypto-js

https://github.com/brix/crypto-js  
https://cryptojs.gitbook.io/docs/


# async await

* 异步依赖实现

# url '=' 

* httt://www.text.com?ddd====&dd==
* 非浏览器环境 注意=需要转义处理