<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [PostgreSQL 表表达式查询知识点](#postgresql-表表达式查询知识点)
  - [1. 基础查询结构](#1-基础查询结构)
    - [FROM 子句（最常用）](#from-子句最常用)
    - [WHERE 子句（过滤数据）](#where-子句过滤数据)
  - [2. JOIN 连接操作（核心知识点）](#2-join-连接操作核心知识点)
    - [INNER JOIN（内连接）](#inner-join内连接)
    - [LEFT OUTER JOIN（左外连接）](#left-outer-join左外连接)
    - [RIGHT OUTER JOIN（右外连接）](#right-outer-join右外连接)
    - [FULL OUTER JOIN（全外连接）](#full-outer-join全外连接)
    - [CROSS JOIN（交叉连接）](#cross-join交叉连接)
    - [USING 子句（简化连接）](#using-子句简化连接)
    - [NATURAL JOIN（自然连接）](#natural-join自然连接)
  - [3. 表别名（实用技巧）](#3-表别名实用技巧)
    - [基础别名](#基础别名)
    - [自连接（必须使用别名）](#自连接必须使用别名)
    - [列别名重命名](#列别名重命名)
  - [4. 子查询（重要概念）](#4-子查询重要概念)
    - [FROM 子句中的子查询](#from-子句中的子查询)
    - [VALUES 列表作为表](#values-列表作为表)
  - [5. LATERAL 子查询（高级特性）](#5-lateral-子查询高级特性)
    - [基础语法](#基础语法)
    - [实际应用场景](#实际应用场景)
    - [示例：查找邻近顶点](#示例查找邻近顶点)
  - [6. GROUP BY 和 HAVING（数据聚合）](#6-group-by-和-having数据聚合)
    - [GROUP BY 基础](#group-by-基础)
    - [HAVING 过滤分组](#having-过滤分组)
    - [功能依赖（PostgreSQL扩展）](#功能依赖postgresql扩展)
  - [7. 高级分组操作](#7-高级分组操作)
    - [GROUPING SETS（多级分组）](#grouping-sets多级分组)
    - [ROLLUP（层次汇总）](#rollup层次汇总)
    - [CUBE（交叉汇总）](#cube交叉汇总)
    - [混合使用](#混合使用)
  - [8. 表函数（特殊用法）](#8-表函数特殊用法)
    - [基础表函数](#基础表函数)
    - [UNNEST 函数（展开数组）](#unnest-函数展开数组)
    - [WITH ORDINALITY（添加行号）](#with-ordinality添加行号)
    - [ROWS FROM（并行返回多函数结果）](#rows-from并行返回多函数结果)
  - [9. 处理 record 返回类型](#9-处理-record-返回类型)
    - [动态定义列结构](#动态定义列结构)
  - [10. 执行顺序和注意事项](#10-执行顺序和注意事项)
    - [执行顺序](#执行顺序)
    - [重要注意事项](#重要注意事项)
      - [JOIN vs WHERE 条件](#join-vs-where-条件)
      - [NATURAL JOIN 的风险](#natural-join-的风险)
      - [LATERAL 的性能考虑](#lateral-的性能考虑)
  - [11. 实战技巧](#11-实战技巧)
    - [自连接查询](#自连接查询)
    - [层次查询（使用递归CTE）](#层次查询使用递归cte)
    - [动态行转列](#动态行转列)
  - [12. 性能优化建议](#12-性能优化建议)
  - [13. 常见错误和解决方案](#13-常见错误和解决方案)
    - [错误1：列名冲突](#错误1列名冲突)
    - [错误2：GROUP BY列不在SELECT中](#错误2group-by列不在select中)
    - [错误3：在WHERE中使用聚合函数](#错误3在where中使用聚合函数)
  - [14. SELECT 列表（数据输出控制）](#14-select-列表数据输出控制)
    - [14.1 基础选择列表项](#141-基础选择列表项)
      - [选择所有列](#选择所有列)
      - [选择特定列](#选择特定列)
      - [值表达式](#值表达式)
    - [14.2 列标签和别名](#142-列标签和别名)
      - [AS 关键字使用](#as-关键字使用)
      - [默认列命名规则](#默认列命名规则)
      - [重要注意事项](#重要注意事项-1)
    - [14.3 DISTINCT 去重](#143-distinct-去重)
      - [基础DISTINCT](#基础distinct)
      - [ALL 关键字（默认行为）](#all-关键字默认行为)
      - [DISTINCT ON（PostgreSQL扩展）](#distinct-onpostgresql扩展)
  - [15. 查询组合操作（UNION、INTERSECT、EXCEPT）](#15-查询组合操作union-intersect-except)
    - [15.1 基础语法](#151-基础语法)
      - [UNION 操作（并集）](#union-操作并集)
      - [INTERSECT 操作（交集）](#intersect-操作交集)
      - [EXCEPT 操作（差集）](#except-操作差集)
  - [16.WITH Queries](#16with-queries)
    - [简化嵌套查询](#简化嵌套查询)
    - [递归查询 (WITH RECURSIVE)](#递归查询-with-recursive)
  - [17.ORDER BY](#17order-by)
  - [18.LIMIT 和 OFFSET](#18limit-和-offset)

<!-- /code_chunk_output -->


# PostgreSQL 表表达式查询知识点

## 1. 基础查询结构

### FROM 子句（最常用）

- 表引用列表：`FROM table1, table2`
- 派生表：子查询、JOIN构造
- 笛卡尔积：多个表时的默认行为 T1 CROSS JOIN T2
- 表继承：`ONLY`关键字控制是否包含子表

### WHERE 子句（过滤数据）

- 基础过滤：`WHERE condition`
- 布尔表达式：返回boolean类型的条件
- 子查询：可以在WHERE中使用子查询
- 注意：与JOIN条件的区别

## 2. JOIN 连接操作（核心知识点）

### INNER JOIN（内连接）

- 只返回匹配的行
- 语法：`T1 INNER JOIN T2 ON condition`
- 可以简写为 `JOIN`

### LEFT OUTER JOIN（左外连接）

```sql
T1 LEFT JOIN T2 ON condition
```

- 保留T1的所有行
- T2不匹配的行用NULL填充

### RIGHT OUTER JOIN（右外连接）

```sql
T1 RIGHT JOIN T2 ON condition
```

- 保留T2的所有行
- T1不匹配的行用NULL填充

### FULL OUTER JOIN（全外连接）

```sql
T1 FULL JOIN T2 ON condition
```

- 保留两个表的所有行
- 不匹配的行用NULL填充

### CROSS JOIN（交叉连接）

```sql
T1 CROSS JOIN T2
```

- 笛卡尔积
- 等价于 `FROM T1, T2`

### USING 子句（简化连接）

```sql
T1 JOIN T2 USING (column1, column2)
```

- 当连接列同名时使用
- 自动去重重复列

### NATURAL JOIN（自然连接）

```sql
T1 NATURAL JOIN T2
```

- 自动匹配所有同名列
- 有风险：可能包含意外的列

## 3. 表别名（实用技巧）

### 基础别名

```sql
FROM table_name AS alias
FROM table_name alias
```

### 自连接（必须使用别名）

```sql
FROM people AS mother
JOIN people AS child ON mother.id = child.mother_id
```

### 列别名重命名

```sql
FROM table_name AS alias(col1, col2)
```

## 4. 子查询（重要概念）

### FROM 子句中的子查询

```sql
FROM (SELECT * FROM table1 WHERE condition) AS subquery
```

### VALUES 列表作为表

```sql
FROM (VALUES ('anne', 'smith'), ('bob', 'jones')) AS names(first, last)
```

## 5. LATERAL 子查询（高级特性）

### 基础语法

```sql
FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss
```

### 实际应用场景

- 为每行调用返回多行的函数
- 依赖于前面表的计算
- 配合LEFT JOIN使用

### 示例：查找邻近顶点

```sql
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;
```

## 6. GROUP BY 和 HAVING（数据聚合）

### GROUP BY 基础

```sql
SELECT product_id, sum(quantity)
FROM sales
GROUP BY product_id;
```

### HAVING 过滤分组

```sql
SELECT department, avg(salary)
FROM employees
GROUP BY department
HAVING avg(salary) > 50000;
```

### 功能依赖（PostgreSQL扩展）

```sql
-- 如果product_id是主键，可以只GROUP BY product_id
SELECT product_id, name, price, sum(quantity)
FROM products p JOIN sales s ON p.id = s.product_id
GROUP BY product_id;  -- name和price依赖于product_id
```

## 7. 高级分组操作

### GROUPING SETS（多级分组）

```sql
SELECT brand, size, color, sum(sales)
FROM products
GROUP BY GROUPING SETS ((brand, size), (brand, color), ());
```

### ROLLUP（层次汇总）

```sql
-- 按地区、省、市的层次汇总
SELECT region, province, city, sum(sales)
FROM sales
GROUP BY ROLLUP (region, province, city);
-- 等价于：
-- GROUP BY GROUPING SETS (
--   (region, province, city),
--   (region, province),
--   (region),
--   ()
-- )
```

### CUBE（交叉汇总）

```sql
SELECT region, product, quarter, sum(sales)
FROM sales
GROUP BY CUBE (region, product, quarter);
-- 生成分区的所有可能组合
```

### 混合使用

```sql
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
-- 最终是这些分组的笛卡尔积
```

## 8. 表函数（特殊用法）

### 基础表函数

```sql
CREATE OR REPLACE FUNCTION GETFOO (INT) RETURNS TABLE (FOOID INT, LAST TEXT) AS $$
  SELECT * FROM (VALUES (1, 'smith'), (2, 'jones')) AS t(f, l) WHERE f = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;
```

### UNNEST 函数（展开数组）

```sql
SELECT * FROM unnest(ARRAY[1,2,3]) AS num;
```

### WITH ORDINALITY（添加行号）

```sql
SELECT * FROM unnest(ARRAY['a','b','c']) WITH ORDINALITY AS t(value, ordinality);

  value  |  ordinality
-----+-----+---
   a |   1
   b |   2
   c |   3
```

### ROWS FROM（并行返回多函数结果）

```sql
SELECT *
FROM ROWS FROM (
    json_to_recordset('[{"a":1,"b":"x"}]') AS (a int, b text),
    generate_series(1, 3)
) AS x(p, q, s);

  p  |  q  | s
-----+-----+---
  1 | x | 1
    |   | 2
    |   | 3
```

## 9. 处理 record 返回类型

### 动态定义列结构

```sql
SELECT *
FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
  AS t1(proname name, prosrc text);
```

## 10. 执行顺序和注意事项

### 执行顺序

1. FROM 子句（确定数据源）
2. WHERE 子句（过滤行）
3. GROUP BY 子句（分组）
4. 聚合函数
5. HAVING 子句（过滤分组）
6. 窗口函数
7. SELECT 列表
8. ORDER BY
9. LIMIT/OFFSET

### 重要注意事项

#### JOIN vs WHERE 条件

- 内连接：ON和WHERE条件等价
- 外连接：条件放在ON和WHERE有区别

```sql
-- 错误：过滤了左连接的结果
FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.col > 5;

-- 正确：在连接前过滤
FROM t1 LEFT JOIN t2 ON t1.id = t2.id AND t2.col > 5;
```

#### NATURAL JOIN 的风险

- 可能包含意外的列匹配
- 表结构改变时行为可能变化
- 建议使用明确的USING或ON

#### LATERAL 的性能考虑

- 可能导致大量重复计算
- 考虑使用EXISTS替代某些场景

## 11. 实战技巧

### 自连接查询

```sql
-- 查找重复记录
SELECT a.id, a.name
FROM users a, users b
WHERE a.id <> b.id AND a.email = b.email;
```

### 层次查询（使用递归CTE）

```sql
WITH RECURSIVE category_tree AS (
    SELECT id, name, parent_id, 1 as level
    FROM categories WHERE parent_id IS NULL
    UNION ALL
    SELECT c.id, c.name, c.parent_id, ct.level + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree;
```

### 动态行转列

```sql
SELECT
    product_id,
    SUM(CASE WHEN month = 'Jan' THEN sales END) AS jan_sales,
    SUM(CASE WHEN month = 'Feb' THEN sales END) AS feb_sales
FROM monthly_sales
GROUP BY product_id;
```

## 12. 性能优化建议

1. **索引使用**：确保JOIN和WHERE条件中的列有适当的索引
2. **避免过度使用CROSS JOIN**：除非确实需要笛卡尔积
3. **合理使用GROUPING SETS**：可以减少扫描次数
4. **LATERAL子查询优化**：考虑是否真的需要，或者可以用其他方式实现
5. **查询分析**：使用EXPLAIN ANALYZE分析查询计划

## 13. 常见错误和解决方案

### 错误1：列名冲突

```sql
-- 错误：两个表都有id列，产生歧义
SELECT id FROM table1, table2;

-- 正确：使用表别名限定
SELECT t1.id FROM table1 t1, table2 t2;
```

### 错误2：GROUP BY列不在SELECT中

```sql
-- 错误：name不在GROUP BY中
SELECT name, max(salary) FROM employees;

-- 正确：使用聚合函数或添加到GROUP BY
SELECT name, max(salary) FROM employees GROUP BY name;
```

### 错误3：在WHERE中使用聚合函数

```sql
-- 错误：不能在WHERE中使用聚合
SELECT department FROM employees WHERE avg(salary) > 50000;

-- 正确：使用HAVING
SELECT department FROM employees GROUP BY department HAVING avg(salary) > 50000;
```

## 14. SELECT 列表（数据输出控制）

### 14.1 基础选择列表项

#### 选择所有列

```sql
-- 选择所有列
SELECT * FROM table_name;

-- 选择特定表的所有列
SELECT table_name.* FROM table_name;
```

#### 选择特定列

```sql
-- 基本列选择
SELECT a, b, c FROM table_name;

-- 处理列名冲突
SELECT tbl1.a, tbl2.a, tbl1.b FROM tbl1, tbl2;
```

#### 值表达式

```sql
-- 计算列
SELECT price * quantity AS total_price FROM orders;

-- 常量表达式
SELECT 'Hello World' AS greeting, 42 AS answer;

-- 函数调用
SELECT upper(name) AS upper_name FROM users;

-- 复杂表达式
SELECT
    CASE
        WHEN age < 18 THEN 'Minor'
        WHEN age BETWEEN 18 AND 65 THEN 'Adult'
        ELSE 'Senior'
    END AS age_group
FROM people;
```

### 14.2 列标签和别名

#### AS 关键字使用

```sql
-- 使用AS指定列别名
SELECT a AS value, b + c AS sum FROM table_name;

-- AS关键字是可选的（但推荐使用）
SELECT a value, b + c sum FROM table_name;

-- 处理关键字冲突
SELECT a AS "from", b + c AS "sum" FROM table_name;
```

#### 默认列命名规则

- 简单列引用：使用原列名
- 函数调用：使用函数名
- 复杂表达式：系统生成通用名称

#### 重要注意事项

```sql
-- 需要AS或双引号的情况（列名是SQL关键字）
SELECT a AS from, b + c AS sum FROM table_name;
SELECT a "from", b + c AS sum FROM table_name;

-- 推荐总是使用AS或双引号，避免未来关键字冲突
SELECT a AS column_name FROM table_name;
```

### 14.3 DISTINCT 去重

#### 基础DISTINCT

```sql
-- 去除完全重复的行
SELECT DISTINCT department FROM employees;

-- 多列去重（多列组合唯一）
SELECT DISTINCT department, job_title FROM employees;
```

#### ALL 关键字（默认行为）

```sql
-- 保留所有行（默认）
SELECT ALL department FROM employees;
-- 等价于
SELECT department FROM employees;
```

#### DISTINCT ON（PostgreSQL扩展）

```sql
-- 基于特定列的去重，保留每组的第一行
SELECT DISTINCT ON (department)
    department,
    employee_name,
    salary
FROM employees
ORDER BY department, salary DESC;

-- 实际应用：获取每个部门薪资最高的员工
SELECT DISTINCT ON (department)
    department,
    name,
    salary,
    hire_date
FROM employees
ORDER BY department, salary DESC, hire_date ASC;
```

## 15. 查询组合操作（UNION、INTERSECT、EXCEPT）

### 15.1 基础语法

#### UNION 操作（并集）
```sql
-- 基础UNION：合并两个查询结果，自动去重
SELECT name FROM employees
UNION
SELECT name FROM contractors;

-- UNION ALL：合并查询结果，保留重复行
SELECT name FROM employees
UNION ALL
SELECT name FROM contractors;
```

#### INTERSECT 操作（交集）
```sql
-- 找出同时在两个查询结果中的行
SELECT product_id FROM orders_2023
INTERSECT
SELECT product_id FROM orders_2024;

-- INTERSECT ALL：保留重复的交集行
SELECT customer_id FROM active_customers
INTERSECT ALL
SELECT customer_id FROM vip_customers;
```

#### EXCEPT 操作（差集）
```sql
-- 找出在第一个查询中但不在第二个查询中的行
SELECT employee_id FROM all_employees
EXCEPT
SELECT employee_id FROM terminated_employees;

-- EXCEPT ALL：保留重复的差集行
SELECT department FROM all_departments
EXCEPT ALL
SELECT department FROM closed_departments;
```

## 16.WITH Queries

WITH 子句正式名称为 CTE（Common Table Expressions，公用表表达式）。它允许你定义一个只在当前查询中存在的临时结果集，极大提高了复杂 SQL 的可读性和维护性。

```sql
WITH 别名 AS (
    -- 这里的子查询只执行一次（通常情况下）
    SELECT ... 
)
SELECT * FROM 别名; -- 在主查询中像引用普通表一样使用它
```

### 简化嵌套查询

```sql
WITH cleaned_data AS (
    -- 第一步：数据清洗
    SELECT 
        id, 
        regexp_replace(phone, '[^0-9]', '', 'g') AS pure_phone
    FROM users
),
location_data AS (
    -- 第二步：提取前缀（模拟地区码）
    SELECT 
        pure_phone,
        left(pure_phone, 3) AS area_code
    FROM cleaned_data
)
-- 第三步：最终汇总
SELECT area_code, COUNT(*) 
FROM location_data
GROUP BY area_code;
```

### 递归查询 (WITH RECURSIVE)

- CTE 最强大的功能，用于处理树状或层级结构（如组织架构、分类树）

```sql
WITH RECURSIVE category_tree AS (
    -- 初始状态：顶级分类
    SELECT id, name, parent_id 
    FROM categories WHERE parent_id IS NULL
  UNION ALL
    -- 递归步：查找子分类
    SELECT c.id, c.name, c.parent_id
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree;
```

## 17.ORDER BY

- ASC（默认）：升序排列（从小到大）。
- DESC：降序排列（从大到小）。

```sql
SELECT column1, column2 
FROM table_name 
ORDER BY column1 ASC, column2 DESC;
```

## 18.LIMIT 和 OFFSET

- LIMIT: 指定返回的最大行数。
- OFFSET: 指定在开始返回行之前要跳过的行数。
- 必须配合 ORDER BY 使用 没有 ORDER BY，LIMIT 返回的行是随机
- OFFSET 的性能瓶颈（深度分页问题）优化建议（游标分页）：使用“寻找上一个 ID”的方式替代 OFFSET

```sql
SELECT column_list
FROM table_name
[ORDER BY column_name]
LIMIT count [OFFSET start];
```