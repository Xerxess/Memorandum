<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [PostgreSQL 17.7 条件表达式](#postgresql-177-条件表达式)
  - [1. COALESCE - 最常用的空值处理函数](#1-coalesce---最常用的空值处理函数)
  - [2. CASE - 通用条件表达式](#2-case---通用条件表达式)
    - [2.1 简单 CASE 表达式](#21-简单-case-表达式)
    - [2.2 搜索 CASE 表达式](#22-搜索-case-表达式)
    - [2.3 实际应用场景](#23-实际应用场景)
  - [3. NULLIF - 条件返回空值](#3-nullif---条件返回空值)
  - [4. GREATEST 和 LEAST - 最大值和最小值函数](#4-greatest-和-least---最大值和最小值函数)
    - [4.1 与 NULL 值的处理](#41-与-null-值的处理)
  - [5. 高级应用和最佳实践](#5-高级应用和最佳实践)
    - [5.1 性能优化建议](#51-性能优化建议)
    - [5.2 复杂业务逻辑示例](#52-复杂业务逻辑示例)
    - [5.3 数据转换和清理](#53-数据转换和清理)
  - [6. 与其他 PostgreSQL 特性的集成](#6-与其他-postgresql-特性的集成)
    - [6.1 与窗口函数结合](#61-与窗口函数结合)
    - [6.2 与 JSON 数据结合](#62-与-json-数据结合)
    - [6.3 与数组操作结合](#63-与数组操作结合)
  - [总结](#总结)

<!-- /code_chunk_output -->


# PostgreSQL 17.7 条件表达式

## 1. COALESCE - 最常用的空值处理函数

COALESCE 函数返回参数中第一个非空值，常用于为空值提供默认值。

```sql

-- 基本用法：返回第一个非空值
SELECT COALESCE(description, short_description, '(none)')
FROM products;

SELECT COALESCE(null, 'abc', '匿名用户')
-- 'abc'

-- 实际应用场景：计算字段时处理空值
SELECT
    id,
    COALESCE(price, 0) as price,
    COALESCE(discount_price, price) as final_price
FROM products;

-- 与其他函数结合使用
SELECT
    name,
    COALESCE(NULLIF(phone, ''), '未提供') as phone
FROM customers;
```

**使用技巧：**
- 常用于数据展示时的默认值替换
- 可以嵌套使用实现复杂的条件逻辑
- 只会评估必要的参数，提高性能

## 2. CASE - 通用条件表达式

CASE 表达式是 SQL 中最强大的条件控制结构，类似于编程语言中的 if-else 语句。

### 2.1 简单 CASE 表达式

```sql
-- 等值判断的简洁写法
SELECT
    name,
    CASE status
        WHEN 1 THEN '激活'
        WHEN 2 THEN '待激活'
        WHEN 3 THEN '已禁用'
        ELSE '未知状态'
    END as status_text
FROM users;

-- 处理枚举值
SELECT
    product_id,
    CASE category_id
        WHEN 1 THEN '电子产品'
        WHEN 2 THEN '服装'
        WHEN 3 THEN '图书'
        ELSE '其他'
    END as category_name
FROM products;
```

### 2.2 搜索 CASE 表达式

```sql
-- 复杂条件判断
SELECT
    name,
    salary,
    CASE
        WHEN salary < 5000 THEN '初级'
        WHEN salary BETWEEN 5000 AND 10000 THEN '中级'
        WHEN salary BETWEEN 10000 AND 20000 THEN '高级'
        WHEN salary > 20000 THEN '专家'
        ELSE '未分类'
    END as level
FROM employees;

-- 多条件组合
SELECT
    order_id,
    amount,
    created_at,
    CASE
        WHEN amount > 10000 AND created_at >= '2024-01-01' THEN 'VIP订单'
        WHEN amount > 5000 THEN '大额订单'
        WHEN created_at >= CURRENT_DATE - INTERVAL '7 days' THEN '新订单'
        ELSE '普通订单'
    END as order_type
FROM orders;

-- 避免除零错误
SELECT
    product_name,
    CASE
        WHEN total_sales > 0 THEN profit / total_sales * 100
        ELSE 0
    END as profit_rate
FROM products;
```

### 2.3 实际应用场景

```sql
-- 动态排序
SELECT *
FROM products
ORDER BY
    CASE
        WHEN category = 'electronics' THEN price
        WHEN category = 'clothing' THEN discount_price
        ELSE price * 0.9
    END DESC;

-- 条件聚合
SELECT
    department,
    COUNT(*) as total_count,
    COUNT(CASE WHEN status = 'active' THEN 1 END) as active_count,
    SUM(CASE WHEN salary > 10000 THEN salary ELSE 0 END) as high_salary_total
FROM employees
GROUP BY department;
```

## 3. NULLIF - 条件返回空值

NULLIF 函数在两个值相等时返回 NULL，否则返回第一个值。

```sql
-- 基本用法：避免特定值
SELECT NULLIF(status, 'deleted') as effective_status
FROM users;

-- 实际应用：除法保护
SELECT
    product_name,
    CASE
        WHEN NULLIF(denominator, 0) IS NULL THEN NULL
        ELSE numerator / denominator
    END as ratio
FROM calculations;

-- 数据清洗：转换特定值为空值
SELECT
    id,
    NULLIF(phone_number, '000-0000-0000') as clean_phone,
    NULLIF(email, 'noreply@example.com') as clean_email
FROM customers;

-- 配合 COALESCE 使用
SELECT
    COALESCE(NULLIF(middle_name, ''), '无') as middle_name_display
FROM users;
```

## 4. GREATEST 和 LEAST - 最大值和最小值函数

这两个函数从一系列值中选择最大值或最小值。

```sql
-- 基本用法
SELECT
    GREATEST(price, discount_price, special_price) as max_price,
    LEAST(price, discount_price, special_price) as min_price
FROM products;

-- 实际应用：数值范围控制
SELECT
    product_name,
    LEAST(GREATEST(user_input_price, min_price), max_price) as validated_price
FROM products;

-- 日期比较
SELECT
    order_id,
    GREATEST(created_at, updated_at, last_activity_at) as latest_activity,
    LEAST(start_date, end_date) as earlier_date
FROM orders;

-- 字符串比较（按字典序）
SELECT
    GREATEST(last_name, maiden_name, married_name) as alphabetically_last_name
FROM users;
```

### 4.1 与 NULL 值的处理

```sql
-- PostgreSQL 特性：NULL 值被忽略，只有全部为 NULL 时才返回 NULL
SELECT
    GREATEST(10, NULL, 30) as result;  -- 返回 30，不是 NULL

-- 实际应用：处理可能为空的数值
SELECT
    product_id,
    GREATEST(
        COALESCE(base_price, 0),
        COALESCE(premium_price, 0),
        COALESCE(special_price, 0)
    ) as effective_price
FROM products;
```

## 5. 高级应用和最佳实践

### 5.1 性能优化建议

```sql
-- CASE 表达式的短路评估
-- 把最可能的条件放在前面
SELECT
    name,
    CASE
        WHEN status = 'active' THEN '正常'  -- 最常见的状态放前面
        WHEN status = 'pending' THEN '待定'
        WHEN status = 'suspended' THEN '暂停'
        ELSE '其他'
    END as status_desc
FROM users;

-- 使用索引友好的条件
WHERE
    CASE
        WHEN indexed_column = value THEN indexed_column = value
        WHEN other_column = other_value THEN true
        ELSE false
    END;
```

### 5.2 复杂业务逻辑示例

```sql
-- 订单计费逻辑
SELECT
    order_id,
    customer_type,
    amount,
    CASE
        -- VIP 客户大额订单
        WHEN customer_type = 'VIP' AND amount > 10000 THEN
            amount * 0.7  -- 30% 折扣

        -- VIP 客户普通订单
        WHEN customer_type = 'VIP' THEN
            amount * 0.85  -- 15% 折扣

        -- 新客户首单优惠
        WHEN is_first_order = TRUE AND amount < 5000 THEN
            amount * 0.9  -- 10% 折扣

        -- 促销期间订单
        WHEN created_at BETWEEN '2024-11-01' AND '2024-11-30' THEN
            GREATEST(amount * 0.95, amount - 100)  -- 5% 折扣或减100，取较大优惠

        -- 默认情况
        ELSE amount
    END as final_amount
FROM orders;

-- 员工薪资计算
SELECT
    employee_id,
    base_salary,
    COALESCE(bonus, 0) as bonus,
    COALESCE(commission, 0) as commission,
    GREATEST(0, base_salary + COALESCE(bonus, 0) + COALESCE(commission, 0) -
             CASE
                 WHEN years_of_service > 10 THEN 5000
                 WHEN years_of_service > 5 THEN 3000
                 ELSE 0
             END) as net_salary
FROM employees;
```

### 5.3 数据转换和清理

```sql
-- 地址标准化
SELECT
    id,
    COALESCE(
        NULLIF(TRIM(address), ''),
        NULLIF(TRIM(alt_address), ''),
        '地址未知'
    ) as normalized_address,
    CASE
        WHEN city = 'Beijing' THEN '北京'
        WHEN city = 'Shanghai' THEN '上海'
        WHEN city = 'Guangzhou' THEN '广州'
        WHEN city = 'Shenzhen' THEN '深圳'
        ELSE COALESCE(city, '未知城市')
    END as normalized_city
FROM customers;

-- 电话号码清理
SELECT
    customer_id,
    CASE
        WHEN phone ~ '^\d{11}$' THEN phone  -- 标准11位手机号
        WHEN phone ~ '^1[3-9]\d{9}$' THEN phone  -- 以1开头的手机号
        WHEN phone LIKE '%-%' THEN REPLACE(phone, '-', '')  -- 去掉横线
        WHEN phone LIKE '% %' THEN REPLACE(phone, ' ', '')  -- 去掉空格
        ELSE NULLIF(phone, '')  -- 其他情况，空字符串转为NULL
    END as clean_phone
FROM customers;
```

## 6. 与其他 PostgreSQL 特性的集成

### 6.1 与窗口函数结合

```sql
-- 计算排名类别
SELECT
    employee_id,
    salary,
    CASE
        WHEN ROW_NUMBER() OVER (ORDER BY salary DESC) <= 10 THEN 'Top 10%'
        WHEN ROW_NUMBER() OVER (ORDER BY salary DESC) <= 50 THEN 'Top 50%'
        ELSE 'Other'
    END as salary_rank_category
FROM employees;
```

### 6.2 与 JSON 数据结合

```sql
-- JSON 条件处理
SELECT
    id,
    metadata,
    CASE
        WHEN metadata->>'type' = 'premium' THEN '高级用户'
        WHEN metadata->>'type' = 'basic' THEN '基础用户'
        WHEN metadata ? 'trial_end' AND (metadata->>'trial_end')::date > CURRENT_DATE THEN '试用用户'
        ELSE '普通用户'
    END as user_category
FROM users;
```

### 6.3 与数组操作结合

```sql
-- 数组条件处理
SELECT
    id,
    tags,
    CASE
        WHEN 'urgent' = ANY(tags) THEN '紧急'
        WHEN 'important' = ANY(tags) THEN '重要'
        WHEN ARRAY_LENGTH(tags, 1) > 5 THEN '多标签'
        WHEN tags IS NULL THEN '无标签'
        ELSE '普通'
    END as priority_level
FROM tasks;
```

## 总结

PostgreSQL 的条件表达式提供了强大的数据操作能力：

1. **COALESCE** - 最常用的空值处理，实际开发中使用频率最高
2. **CASE** - 最灵活的条件控制，支持复杂的业务逻辑
3. **NULLIF** - 特定场景下的空值转换，常用于数据清理
4. **GREATEST/LEAST** - 数值比较，常用于范围控制和数据验证