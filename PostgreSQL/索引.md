<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [索引](#索引)
  - [B-Tree (最常用)](#b-tree-最常用)
  - [Hash](#hash)
  - [GiST / SP-GiST](#gist--sp-gist)
  - [GIN (Generalized Inverted Index)](#gin-generalized-inverted-index)
  - [BRIN (Block Range Index)](#brin-block-range-index)

<!-- /code_chunk_output -->

# 索引

## B-Tree (最常用)

- 适用场景：几乎所有排序查询、范围查询（<, <=, =, >=, >）以及排序操作。
- 特点：默认索引类型，平衡树结构，性能稳定。
- 在创建索引时没有指定类型（如 CREATE INDEX ...），PostgreSQL 就会自动创建一个 B-Tree 索引。

```sql
-- 语法：CREATE INDEX 索引名称 ON 表名 (列名);
CREATE INDEX idx_users_username ON users (username);

-- CONCURRENTLY 不会阻塞读写，但执行速度略慢
CREATE INDEX CONCURRENTLY idx_users_email ON users (email);

-- 注意：列的顺序很重要，过滤性最强的列放最左侧
CREATE INDEX idx_location ON address (province, city, district);
```

## Hash

- 适用场景：仅用于简单的等值比较（=）。
- 特点：在处理长字符串的完全匹配时，体积可能比 B-Tree 更小。

```sql
-- 语法：CREATE INDEX 索引名 ON 表名 USING HASH (列名);
CREATE INDEX idx_user_uuid_hash ON users USING HASH (uuid);
```

## GiST / SP-GiST

- 适用场景：地理空间数据（PostGIS）、全文检索、范围类型（如时间段重叠）。
- GiST 索引支持 <<  、 &< 、 &> 、  >> 、  <<| 、  &<| 、  |&>  、 |>>  、 @> 、  <@ 、  ~=  、 &&
- SP-GiST 索引与 GiST 索引类似 支持 << 、  >> 、  ~=  、 <@  、 <<| 、  |>>

GiST 与 SP-GiST 的对比

特性| GiST| SP-GiST
-|-|-
空间划分 |允许子区域重叠 |子区域不重叠 (Space Partitioning)
平衡性 |始终是平衡树 |通常是非平衡树
多列支持 |支持多列复合索引 |仅限单列
K-近邻 (K-NN) |完美支持 (例如：找最近的10个点) |部分支持 (取决于具体操作符类)
性能优势 |适应性极强，适合重叠严重的几何体 |查找速度极快，适合路径和空间分发数据

```sql
-- 创建 GiST 索引 (空间几何)
CREATE INDEX idx_geom ON locations USING GIST (geom);

-- 创建 SP-GiST 索引 (IP 地址)
CREATE INDEX idx_ip_prefix ON network_logs USING SPGIST (ip_address);
```

## GIN (Generalized Inverted Index)

- 适用场景：JSONB、数组、全文搜索。
- 特点：适合处理“多值”字段，例如查询 JSON 中是否包含某个键值对。

```sql
-- 创建针对 JSONB 的 GIN 索引
CREATE INDEX idx_user_data ON users USING GIN (profile_data);

-- 这种查询将直接命中索引（耗时从秒级降至毫秒级）
SELECT * FROM users WHERE profile_data @> '{"city": "Beijing"}';

```

```sql
-- 对文本列创建全文搜索索引
CREATE INDEX idx_post_content ON posts USING GIN (to_tsvector('chinese', content));

```

## BRIN (Block Range Index)

- 适用场景：海量时序数据（如按时间顺序插入的日志）
- 特点：占用空间极小，但仅适用于物理存储顺序与逻辑顺序高度一致的情况。
- B-Tree 索引可能占用数百 GB，而同一个表的 BRIN 索引通常只有几 MB
  - 案例：对于一个 100GB 的日志表，B-Tree 索引可能需要 20GB，而 BRIN 可能只需 50MB。
- 局限性
  - 不适合乱序数据：如果你的数据是随机插入的（例如随机生成的 UUID），BRIN 的 min/max 范围会覆盖整个数据域，导致索引失效
  - 非精确查找：BRIN 只能告诉你数据“可能在这些块里”，不能精确定位到某一行。因此，它通常用于返回大量结果的范围查询，而非通过 ID 找一个人的点查询。
- 什么时候选 BRIN
  - 按 ID 查找单行 B-Tree
  - 小表 (几万行以内) B-Tree
  - TB 级日志表/流水表 (按时间插入) BRIN
  - 存储空间极度受限 BRIN

```sql
-- 语法：CREATE INDEX ... USING BRIN (列名);
CREATE INDEX idx_logs_created_at_brin ON system_logs USING BRIN (created_at);
```
