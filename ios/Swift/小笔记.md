<!-- TOC -->

- [小笔记](#%E5%B0%8F%E7%AC%94%E8%AE%B0)
    - [基础小节](#%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%8A%82)
    - [字符串](#%E5%AD%97%E7%AC%A6%E4%B8%B2)
    - [集合](#%E9%9B%86%E5%90%88)
    - [函数](#%E5%87%BD%E6%95%B0)
    - [闭包](#%E9%97%AD%E5%8C%85)
    - [基本运算符](#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6)
    - [值类型](#%E5%80%BC%E7%B1%BB%E5%9E%8B)
    - [引用类型](#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)
    - [元类型和.SELF](#%E5%85%83%E7%B1%BB%E5%9E%8B%E5%92%8Cself)

<!-- /TOC -->

# 小笔记

## 基础小节

> 一行中声明多个常量或多个变量，以逗号分隔

```swift
var x = 0.0, y = 0.0, z = 0.0
```

> 一行中定义相同类型的多个相关变量，以逗号分隔，并在最终变量名称后使用单个类型注释

```swift
var red, green, blue: Double
```

> Swift在推断浮点数的类型时总是选择Double（而不是Float）。

> 强制展开 !

```swift
// 感叹号实际上是在说，“我知道这个可选的肯定有一个值；请使用它。
convertedNumber!
```

> 可选绑定

使用可选绑定来查明可选是否包含一个值，如果是，则将该值作为`临时常量或变量使用`。可选绑定可以与if、while语句一起使用，以检查可选内部的值，并将该值提取到常量或变量中，作为单个操作的一部分。

```swift
if let constantName = someOptional {
    statements
}
```

> 在访问其包含的值后不需要引用原始的可选常量或变量，则可以对新常量或变量使用相同的名称

```swift
let myNumber = Int(possibleNumber)
// Here, myNumber is an optional integer
if let myNumber = myNumber {
    // Here, myNumber is a non-optional integer
    print("My number is \(myNumber)")
}
// Prints "My number is 123"
```

```swift
// 以上精简方式
if let myNumber {
    print("My number is \(myNumber)")
}
// Prints "My number is 123"
```

> 单个if语句中包含尽可能多的可选绑定和布尔条件，并以逗号分隔

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Prints "4 < 42 < 100"
```

> 隐式解析可选类型

程序的结构中可以清楚地看出，在首次设置值之后，可选值将始终具有值。在这些情况下，消除每次访问时检查和解包可选值的需要是很有用的，因为可以安全地假设它始终具有值。

您可以将隐式展开的可选项视为允许在需要时强制展开可选项。

```swift
var implicitlyUnwrappedString: String!
var implicitlyUnwrappedString: ImplicitlyUnwrappedOptional<String>
```

> 可选链

可选链会选择性的执行隐式解析可选表达式上的某一个操作。如果值为nil，就不会执行任何操作，因此也不会产生运行错误。

> 错误处理

```swift
func canThrowAnError() throws {
    // this function may or may not throw an error
}

do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```

> 断言和先决条件

断言和先决条件是在`运行`时所做的检查  
断言或者先决条件中的布尔条件评估的结果为 true（真），则代码像往常一样继续执行。  
如果布尔条件评估结果为 false（假），程序的当前状态是`无效`的，`则代码执行结束，应用程序中止`。

你使用断言和先决条件来表达你所做的假设和你在编码时候的期望。你可以将这些包含在你的代码中。`断言`帮助你在开发阶段找到错误和不正确的假设，先决条件帮助你在`生产环境`中探测到存在的问题。

断言和先决条件的不同点:

- 断言仅在调试环境运行
- 先决条件则在调试环境和生产环境中运行

```swift
// assert(_:_:file:line:)
let age = -3
assert(age >= 0, "A person's age cannot be less than zero")
// 因为 age < 0，所以断言会触发

assert(age >= 0) // 如果不需要断言信息，可以就像这样忽略掉

// 代码已经检查了条件
// assertionFailure(_:file:line:)
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age >= 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}
```

```swift
// precondition(_:_:file:line:)您通过调用函数编写前提条件。
// 只要条件可能为假，就使用前提条件，但必须绝对为真，您的代码才能继续执行。
```

## 字符串

> 字符串插值

字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。

```swift
let multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
// message 是 "3 times 2.5 is 7.5"
```

## 集合

Swift 中的`数组、集合和字典`总是清楚它们可以存储的值和键的类型。  
这意味着您不能错误地将错误类型的值插入到集合中。

> 集合（Sets）

- 没有确定顺序
- 集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。
- 一个类型为了存储在集合中，该类型必须是`可哈希化`的——也就是说，该类型必须提供一个方法来计算它的哈希值。
- Swift 集合的类型写为Set<Element>，其中Element是集合允许存储的类型。与`数组不同，集合没有等效的速记形式`。

> 字典(Dictionary)

- 字典存储集合中`相同类型的键`和`相同类型的值`之间的关联，`没有定义顺序`。
- 字典`Key类型必须符合Hashable`协议，就像集合的值类型一样
- updateValue(_:forKey:)返回旧值
- updateValue(_:forKey:)方法返回字典值类型的可选值

```swift
// 从字典中删除键值对nil
airports["APL"] = nil
airports.removeValue(forKey: "APL")
```

## 函数

> 隐式返回

- 写一行的任何函数return都可以省略return.
- 属性 getter 也可以使用隐式返回

```swift
// 
func greeting(for person: String) -> String {
    "Hello, " + person + "!"
}
```

> 特殊的类型值Void

```swift
// 没有定义返回类型的函数返回一个特殊的类型值Void
func greet(person: String) {
    print("Hello, \(person)!")
}
```

> 默认参数值

- 通过在参数类型之后为参数赋值来为函数中的任何参数定义默认值

> 可变参数

- 函数能拥有多个可变参数。可变参数后的第一个行参前必须加上实参标签。实参标签用于区分实参是传递给可变参数，还是后面的行参。

```swift
func arithmeticMean(_ numbers: Double...,_ string:String...) {
}
```

> 函数类型

```swift
var mathFunction: (Int, Int) -> Int = addTwoInts
```

> 输入输出参数

- 默认情况下，函数参数是常量。
- 通过将inout关键字放在参数类型之前来编写输入输出参数。
- 只能将变量作为输入输出参数的参数传递
- 不能将常量或文字值作为参数传递，因为无法修改常量和文字。
- 将变量作为参数传递给输入输出参数时，您可以在变量名称前直接放置一个符号 ( &)，以指示它可以被函数修改。

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// Prints "someInt is now 107, and anotherInt is now 3"
```

> 嵌套函数

```swift
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
```

## 闭包

- 闭包表达式语法中的参数可以是in-out参数;
- 参数不能有默认值;

```swift
{ (parameters) -> return type in
    statements
}
```

## 基本运算符

> 空合运算符

```swift
// 以下两则相同
// a ?? b
// a != nil ? a! : b 
```

> 范围运算符

- 闭区间运算符( a...b) 定义从a到的范围b，并包括值a和b
- 半开范围运算符(a..<b)定义从a到的范围b，但不包括b。
- a..|..a  在一个方向上尽可能连续的范围

```swfit
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}

for i in 0..<count {
    print("Person \(i + 1) is called \(names[i])")
}

for name in names[2...] {
    print(name)
}
```

## 值类型

Swift 中所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型的属性，在代码中传递的时候都会被复制。

- 结构体
- 枚举

以下都是值类型，其底层也是使用结构体实现的：

- 整数（integer）
- 浮点数（floating-point number）
- 布尔值（boolean）
- 字符串（string)
- 数组（array）
- 字典（dictionary）

## 引用类型

- 类
- 闭包
- Actors

## 元类型和.SELF

元类型:指任意类型的类型，包括类类型、结构体类型、枚举类型和协议类型。  
类、结构体或枚举类型的元类型是相应的类型名紧跟 .Type。  
协议类型的元类型——并不是运行时遵循该协议的具体类型——是该协议名字紧跟
.Protocol。比如，类 SomeClass 的元类型就是 SomeClass.Type，协议 SomeProtocol 的元类型就是 SomeProtocal.Protocol。

.self 表达式来获取类型。比如，SomeClass.self 返回 SomeClass 本身，而不是 SomeClass 的一个实例。

常用于框架中，来实现类型的传递

```swift
typealias AnyClass = AnyObject.Type

class A {

}

let typeA: A.Type = A.self

class A {
    class func method() {
        print("Hello")
    }
}

let typeA: A.Type = A.self
typeA.method()

// 或者
let anyClass: AnyClass = A.self
(anyClass as! A.Type).method()
```
