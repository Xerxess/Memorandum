<!-- TOC -->

- [小笔记](#%E5%B0%8F%E7%AC%94%E8%AE%B0)
    - [基础小节](#%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%8A%82)
    - [基本运算符](#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6)
    - [值类型](#%E5%80%BC%E7%B1%BB%E5%9E%8B)
    - [引用类型](#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)
    - [元类型和.SELF](#%E5%85%83%E7%B1%BB%E5%9E%8B%E5%92%8Cself)

<!-- /TOC -->

# 小笔记

## 基础小节

> 一行中声明多个常量或多个变量，以逗号分隔

```swift
var x = 0.0, y = 0.0, z = 0.0
```

> 一行中定义相同类型的多个相关变量，以逗号分隔，并在最终变量名称后使用单个类型注释

```swift
var red, green, blue: Double
```

> Swift在推断浮点数的类型时总是选择Double（而不是Float）。

> 强制展开 !

```swift
// 感叹号实际上是在说，“我知道这个可选的肯定有一个值；请使用它。
convertedNumber!
```

> 可选绑定

使用可选绑定来查明可选是否包含一个值，如果是，则将该值作为`临时常量或变量使用`。可选绑定可以与if、while语句一起使用，以检查可选内部的值，并将该值提取到常量或变量中，作为单个操作的一部分。

```swift
if let constantName = someOptional {
    statements
}
```

> 在访问其包含的值后不需要引用原始的可选常量或变量，则可以对新常量或变量使用相同的名称

```swift
let myNumber = Int(possibleNumber)
// Here, myNumber is an optional integer
if let myNumber = myNumber {
    // Here, myNumber is a non-optional integer
    print("My number is \(myNumber)")
}
// Prints "My number is 123"
```

```swift
// 以上精简方式
if let myNumber {
    print("My number is \(myNumber)")
}
// Prints "My number is 123"
```

> 单个if语句中包含尽可能多的可选绑定和布尔条件，并以逗号分隔

```swift
if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}
// Prints "4 < 42 < 100"

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}
// Prints "4 < 42 < 100"
```

> 隐式解析可选类型

程序的结构中可以清楚地看出，在首次设置值之后，可选值将始终具有值。在这些情况下，消除每次访问时检查和解包可选值的需要是很有用的，因为可以安全地假设它始终具有值。

您可以将隐式展开的可选项视为允许在需要时强制展开可选项。

```swift
var implicitlyUnwrappedString: String!
var implicitlyUnwrappedString: ImplicitlyUnwrappedOptional<String>
```

> 可选链

可选链会选择性的执行隐式解析可选表达式上的某一个操作。如果值为nil，就不会执行任何操作，因此也不会产生运行错误。

> 错误处理

```swift
func canThrowAnError() throws {
    // this function may or may not throw an error
}

do {
    try canThrowAnError()
    // no error was thrown
} catch {
    // an error was thrown
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
```

> 断言和先决条件

断言和先决条件是在`运行`时所做的检查  
断言或者先决条件中的布尔条件评估的结果为 true（真），则代码像往常一样继续执行。  
如果布尔条件评估结果为 false（假），程序的当前状态是`无效`的，`则代码执行结束，应用程序中止`。

你使用断言和先决条件来表达你所做的假设和你在编码时候的期望。你可以将这些包含在你的代码中。`断言`帮助你在开发阶段找到错误和不正确的假设，先决条件帮助你在`生产环境`中探测到存在的问题。

断言和先决条件的不同点:
- 断言仅在调试环境运行
- 先决条件则在调试环境和生产环境中运行

```swift
// assert(_:_:file:line:)
let age = -3
assert(age >= 0, "A person's age cannot be less than zero")
// 因为 age < 0，所以断言会触发

assert(age >= 0) // 如果不需要断言信息，可以就像这样忽略掉

// 代码已经检查了条件
// assertionFailure(_:file:line:)
if age > 10 {
    print("You can ride the roller-coaster or the ferris wheel.")
} else if age >= 0 {
    print("You can ride the ferris wheel.")
} else {
    assertionFailure("A person's age can't be less than zero.")
}
```

```swift
// precondition(_:_:file:line:)您通过调用函数编写前提条件。
// 只要条件可能为假，就使用前提条件，但必须绝对为真，您的代码才能继续执行。
```

## 基本运算符

> 空合运算符

```swift
// 以下两则相同
// a ?? b
// a != nil ? a! : b 
```

> 范围运算符

* 闭区间运算符( a...b) 定义从a到的范围b，并包括值a和b
* 半开范围运算符(a..<b)定义从a到的范围b，但不包括b。
* a..|..a  在一个方向上尽可能连续的范围

```swfit
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}

for i in 0..<count {
    print("Person \(i + 1) is called \(names[i])")
}

for name in names[2...] {
    print(name)
}
```

## 值类型

Swift 中所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型的属性，在代码中传递的时候都会被复制。

- 结构体
- 枚举

以下都是值类型，其底层也是使用结构体实现的：

- 整数（integer）
- 浮点数（floating-point number）
- 布尔值（boolean）
- 字符串（string)
- 数组（array）
- 字典（dictionary）

## 引用类型

- 类
- 闭包
- Actors

## 元类型和.SELF

元类型:指任意类型的类型，包括类类型、结构体类型、枚举类型和协议类型。  
类、结构体或枚举类型的元类型是相应的类型名紧跟 .Type。  
协议类型的元类型——并不是运行时遵循该协议的具体类型——是该协议名字紧跟
.Protocol。比如，类 SomeClass 的元类型就是 SomeClass.Type，协议 SomeProtocol 的元类型就是 SomeProtocal.Protocol。

.self 表达式来获取类型。比如，SomeClass.self 返回 SomeClass 本身，而不是 SomeClass 的一个实例。

常用于框架中，来实现类型的传递

```swift
typealias AnyClass = AnyObject.Type

class A {

}

let typeA: A.Type = A.self

class A {
    class func method() {
        print("Hello")
    }
}

let typeA: A.Type = A.self
typeA.method()

// 或者
let anyClass: AnyClass = A.self
(anyClass as! A.Type).method()
```
