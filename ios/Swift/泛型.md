<!-- TOC -->

- [泛型](#%E6%B3%9B%E5%9E%8B)
    - [命名类型参数](#%E5%91%BD%E5%90%8D%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0)
    - [泛型类型](#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B)
    - [泛型扩展](#%E6%B3%9B%E5%9E%8B%E6%89%A9%E5%B1%95)
    - [类型约束语法](#%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E8%AF%AD%E6%B3%95)
    - [关联类型](#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B)

<!-- /TOC -->

# 泛型

泛型代码让你能根据自定义的需求，`编写出适用于任意类型的、灵活可复用的函数及类型`。
你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

## 命名类型参数

终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名

## 泛型类型

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
```

## 泛型扩展

当对泛型类型进行扩展时，你并不需要提供类型参数列表作为定义的一部分。

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}

extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
```

## 类型约束语法

```swift
// 第一个类型参数 T 必须是 SomeClass 子类；第二个类型参数 U 必须符合 SomeProtocol 协议。
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // 这里是泛型函数的函数体部分
}
```

```swift
// Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符（!=），从而能对该类型的任意两个值进行比较。
// 所有的 Swift 标准类型自动支持 Equatable 协议。
func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

## 关联类型

```swift

```

```swift

```
