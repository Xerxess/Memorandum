# SOLID、KISS、YAGNI

* [SOLID](#solid)
* [KISS](#kiss)
* [YAGNI](#yagni)
* [DRY](#dry)
* [Rule Of Three](#ruleofthree)

# <i id="solid"></i><span>SOLID</span>是面向对象设计和编程(OOD&OOP)中几个重要编码原则

即：SRP单一责任原则；

　　OCP开放封闭原则；

　　LSP里氏替换原则；

　　ISP接口分离原则；

　　DIP依赖倒置原则。

1. 单一责任原则（SRP）
      当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。

2. 开放封闭原则（OCP）
软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。

(1)通过增加代码来扩展功能，而不是修改已经存在的代码。
(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。
(3)OCP支持替换的服务，而不用修改客户模块。

3. 里氏替换原则（LSP）

当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系

客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。

4. 接口分离原则（ISP）

不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。 

客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。

5. 依赖注入或倒置原则（DIP）

1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 
2. 抽象不应该依赖于细节，细节应该依赖于抽象

这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。

(1).高层模块不要依赖低层模块；
(2).高层和低层模块都要依赖于抽象；
(3).抽象不要依赖于具体实现； 
(4).具体实现要依赖于抽象；
(5).抽象和接口使模块之间的依赖分离。


# <i id="kiss"></i>KISS

KISS原则（Kiss Principle）是什么
KISS是 Keep It Simple,Stupid。
其核心思想就是“解耦，解耦，再解耦”，职责单一化，功能单一化为以后的维护和重构都会带来极大的便利。

KISS原则的好处
以更快的速度解决更多的问题
以很简洁的代码来解决很复杂的问题
能写出高质量的代码
能完成更大的系统并且它很容易维护
你所编写的代码会更加灵活，易于扩展、修改或重构。并且能够适应需求的变化。
如何在工作中实践KISS原则
先解决问题，再考虑编码。先将问题拆分的足够小，再动手编码完成这些功能
尽量缩短每个方法，它只要负责解决一个问题就足够了。每个方法的代码最多不要超过30-40行。
如果在方法中需要兼容很多条件，那么你应该将这些条件拆分为更小粒度的方法。
经常重构你所编写的代码。不要害怕删除代码
在其它所有情况下，尽量保持代码的简洁。
想要做出KISS的方案，就必须对面对的问题有透彻的了解，有足够的经验和能力，并经过深思熟虑，这才能做出简洁的抽象。


# <i id="yagni"></i>YAGNI

YAGNI是 You aren't gonna need it 的缩写，意思是"你不会需要它"。
这是"极限编程"提倡的原则，指的是你自以为有用的功能，实际上都是用不到的。因此，除了最核心的功能，其他功能一概不要部署，这样可以大大加快开发。

它背后的指导思想，就是尽可能快、尽可能简单地让软件运行起来（do the simplest thing that could possibly work）。

但是，这里出现了一个问题。仔细推敲的话，你会发现DRY原则和YAGNI原则并非完全兼容。前者追求"抽象化"，要求找到通用的解决方法；后者追求"快和省"，意味着不要把精力放在抽象化上面，因为很可能"你不会需要它"。所以，就有了第三个原则。


# <i id="dry"></i>DRY

DRY是 Don't repeat yourself 的缩写，意思是"不要重复自己"。
软件工程名著《The Pragmatic Programmer》首先提出了这个原则。它的涵义是，系统的每一个功能都应该有唯一的实现。也就是说，如果多次遇到同样的问题，就应该抽象出一个共同的解决方法，不要重复开发同样的功能。

这个原则有时也称为"一次且仅一次"原则（Once and Only Once）。

# <i id="ruleofthree"></i>Rule Of Three

Rule of three 称为"三次原则"，指的是当某个功能第三次出现时，才进行"抽象化"。

这是软件开发大家Martin Fowler在《Refactoring》一书中提出的。

它的涵义是，第一次用到某个功能时，你写一个特定的解决方法；第二次又用到的时候，你拷贝上一次的代码；第三次出现的时候，你才着手"抽象化"，写出通用的解决方法。

这样做有几个理由：

（1）省事。如果一种功能只有一到两个地方会用到，就不需要在"抽象化"上面耗费时间了。

（2）容易发现模式。"抽象化"需要找到问题的模式，问题出现的场合越多，就越容易看出模式，从而可以更准确地"抽象化"。

比如，对于一个数列来说，两个元素不足以判断出规律：

　　1, 2, _, _, _, _,

第三个元素出现后，规律就变得较清晰了：

　　1, 2, 4, _, _, _,

（3）防止过度冗余。如果一种功能同时有多个实现，管理起来非常麻烦，修改的时候需要修改多处。在实际工作中，重复实现最多可以容忍出现一次，再多就无法接受了。

综上所述，"三次原则"是DRY原则和YAGNI原则的折衷，是代码冗余和开发成本的平衡点，值得我们在"抽象化"时遵循。
