<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [dangerouslySetInnerHTML 设置内部 HTML](#dangerouslysetinnerhtml-设置内部-html)
- [组件定义不要把它们的定义嵌套](#组件定义不要把它们的定义嵌套)
- [自定义 hook 传递对象处理 (可能导致死循环)](#自定义-hook-传递对象处理-可能导致死循环)
- [use 死循环](#use-死循环)
- [params（动态路由参数）  searchParams（URL 参数）](#params动态路由参数--searchparamsurl-参数)
  - [服务组件](#服务组件)
  - [客户端组件](#客户端组件)
- [cloneElement 替代方案](#cloneelement-替代方案)
- [闭包陷阱](#闭包陷阱)
  - [解决方案](#解决方案)
- [useEffect 移除不必要依赖 （读取 Effect 的最新 props 和 state，但并不对它们做出“反应”）](#useeffect-移除不必要依赖-读取-effect-的最新-props-和-state但并不对它们做出反应)

<!-- /code_chunk_output -->

# dangerouslySetInnerHTML 设置内部 HTML

- dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML 的替换方案。

```tsx
const markup = { __html:'<p>some raw html</p>' };
return <div dangerouslySetInnerHTML={markup} />;
```

# 组件定义不要把它们的定义嵌套

```tsx
import { useState } from 'react';

export default function MyComponent() {
  const [counter, setCounter] = useState(0);

  // 嵌套组件会导致每次渲染不同不组件
  function MyTextField() {
    const [text, setText] = useState('');

    return (
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
    );
  }

  return (
    <>
      <MyTextField />
      <button onClick={() => {
        setCounter(counter + 1)
      }}>点击了 {counter} 次</button>
    </>
  );
}

```

# 自定义 hook 传递对象处理 (可能导致死循环)

- 常见问题 const { count, sum } = useHook({ age: [] }); 直接引入不稳定的数组对象[],如何hook 内部使用age作为依赖可能会死循环

```tsx
function useHook({ age }) {
  const [s,setS] = useState([])
  useEffect(() => {
    // 修改其他State,会导致hook所在组件重新渲染至死循环，要规避
  }, [age])
  return {s}
}

function MyComponent() {
  console.log('MyComponent')
  const dd = useHook({ age: [] }) // 注意这里直接传递[] 导致每次渲染对象都不同
  return <div></div>
}
```

解决方案:

- 外部(调用端)
- 内部(hook内部)

> 外部(调用端)

```tsx
// 1.调用端把引用稳定住
const ages = useMemo(() => [a, b, c], [a, b, c]);
const { count, sum } = useHook({ age: ages });

// 2.用 useRef
const agesRef = useRef([18, 20, 30]);
const { count, sum } = useHook({ age: agesRef.current });
```

> 内部(hook内部)

```tsx
// 1.浅比较数组内容，内容未变则复用旧引用
function useStableArray<T>(arr: T[]) {
  const ref = React.useRef(arr);
  const same =
    arr.length === ref.current.length &&
    arr.every((v, i) => Object.is(v, ref.current[i]));
  if (!same) ref.current = arr;
  return ref.current;
}

function useHook({ age = [] as number[] } = {}) {
  const stableAge = useStableArray(age);
  const sum = React.useMemo(
    () => stableAge.reduce((s, n) => s + n, 0),
    [stableAge]
  );
  React.useEffect(() => {
    // 仅在“内容”变化时触发
  }, [stableAge]);
  return { sum, count: stableAge.length };
}

// 2.依赖“内容 key”（简单实用） 规范化（排序、去重、裁剪到 0~1），生成一个字符串 key；useEffect 依赖 key，而不是数组引用
function normalizeThreshold(t: number | number[]): number | number[] {
  if (Array.isArray(t)) {
    const arr = t
      .filter((n) => Number.isFinite(n))
      .map((n) => Math.min(1, Math.max(0, n)))
      .sort((a, b) => a - b);
    // 去重
    return arr.filter((v, i) => i === 0 || v !== arr[i - 1]);
  }
  const v = Number.isFinite(t) ? t : 0;
  return Math.min(1, Math.max(0, v));
}

function thresholdKey(t: number | number[]) {
  return Array.isArray(t) ? normalizeThreshold(t).join(',') : String(normalizeThreshold(t));
}

function useHook({ age = [] as number[] } = {}) {
  const sum = React.useMemo(
    () => age.reduce((s, n) => s + n, 0),
    [age]
  );
  React.useEffect(() => {
    // 仅在“内容”变化时触发
  }, [thresholdKey(age)]);
  return { sum, count: stableAge.length };
}
```

# use 死循环

```tsx
// resource 确保是一个不变的Promise or context.
const value = use(resource);
```

```tsx
// 错误示例
function fetchData() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('Data loaded with use Hook!');
    }, 2000);
  });
}

export default function UsersTable({dataPromise}:any) {
  const data = use(fetchData()); // 每次生成不同 Promise 死循环
  return (
    <>
    {data}
    </>
  )
}
```

```tsx
// 正确示例
function fetchData() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('Data loaded with use Hook!');
    }, 2000);
  });
}

let cache = new Map();
export function createPromise() {
  if (!cache.has('url')) {
    cache.set('url', fetchData2());
  }
  return cache.get('url');
}

export default function UsersTable({dataPromise}:any) {
  const data = use(createPromise()); // 缓存相同 Promise 
  return (
    <>
    {data}
    </>
  )
}
```

# params（动态路由参数）  searchParams（URL 参数）

## 服务组件

```tsx
// 都是 Promise 对象
export default async function Page({
  params，
  searchParams,
}: {
  params:Promise<{ [key:string]: string | string[] | undefined }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const { slug } = await params
  const filters = (await searchParams).filters
}
```

## 客户端组件

```tsx
// 客户端组件（不能是 async）中使用 searchParams 和 params，你可以使用 React 的 use 函数来读取 promise
'use client'
import { use } from 'react'
export default function Page({
  params,
  searchParams,
}: {
  params: Promise<{ [key: string]: string | string[] | undefined }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const { slug } = use(params)
  const { query } = use(searchParams)
}
```

# cloneElement 替代方案

<https://zh-hans.react.dev/reference/react/cloneElement#passing-data-with-a-render-prop>

```ts
// cloneElement 允许你使用一个元素作为初始值创建一个新的 React 元素。
const clonedElement = cloneElement(element, props, ...children)
```

```ts
// 具有不同的 props 和 children
import { cloneElement } from 'react';
const clonedElement = cloneElement(
  <Row title="Cabbage">
    Hello
  </Row>,
  { isHighlighted: true },
  'Goodbye'
);
```

- 通过 props 传递数据
- 通过 context 传递数据
- 将逻辑提取到自定义 Hook 中

# 闭包陷阱

闭包陷阱 指的是函数内部访问了过期的变量值，导致逻辑错误
闭包陷阱场景:

- setInterval / setTimeout
- 异步操作中的状态访问
- 事件处理函数中的状态更新

```tsx
// 问题：setInterval 回调函数捕获了 组件首次渲染时的 count 值（0），永远不会再改变。
function Counter() {
  const [count, setCount] = useState(0);

  // 闭包陷阱：setInterval 捕获了过期的 count 值
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('当前 count:', count); // 这里始终显示初始值 0！
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(timer);
  }, []); // 空依赖数组

  return <div>Count: {count}</div>;
}
```

## 解决方案

```tsx
// 方案一：函数式状态更新
// 使用 setState 的函数形式
const [count, setCount] = useState(0);

// ❌ 错误：捕获过期值
setCount(count + 1);

// ✅ 正确：使用函数式更新
setCount(prevCount => prevCount + 1);
```

```tsx
// 方案二：使用 useRef
function RefSolution() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  // 同步状态到 ref
  useEffect(() => {
    countRef.current = count;
  }, [count]);

  useEffect(() => {
    const timer = setInterval(() => {
      console.log('ref 中的值:', countRef.current);
      setCount(prev => prev + 1);
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return <div>{count}</div>;
}
```

```tsx
// 方案三：依赖项管理
function DependencySolution() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    return () => clearInterval(timer);
  }, [setCount]); // 依赖 setter 函数（稳定引用）

  return <div>{count}</div>;
}
```

```tsx
// 方案四：自定义 Hook 封装
```

# useEffect 移除不必要依赖 （读取 Effect 的最新 props 和 state，但并不对它们做出“反应”）

默认情况下，从 Effect 读取响应式值时，必须将其添加为依赖项。这样可以确保 Effect 对该值的每次变化都做出“响应”。对于大多数依赖项而言，这正是我们想要的行为。然而，有时您可能希望读取 Effect 的最新 props 和 state，但并不对它们做出“反应”。

方案：

- react 19.2 可使用useEffectEvent
- 使用useRef自定义 hook  - useEventCallback 参考：<https://usehooks-ts.com/react-hook/use-event-callback>

特性| 社区版 useEventCallback| useEffectEvent
-|-|-
依赖管理 |需要手动声明依赖 |自动捕获依赖
执行时机 |同步更新，可能有时序问题 |React 调度，确保状态最新
并发兼容| 可能状态不一致 |完全兼容并发渲染
调用限制 |无限制 |只能在 effect 内使用

```tsx
// react 19.2  useEffectEvent
function Page({ url, shoppingCart }) {
  // 读取最新值
  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, shoppingCart.length)
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // ✅ All dependencies declared 不需要添加shoppingCart依赖
}
```

```tsx
// 使用useRef自定义 hook  - useEventCallback
function useEventCallback(fn) {
  const ref = useRef(fn);
  useEffect(() => { ref.current = fn; }, [fn]);
  return useCallback((...args) => ref.current(...args), []);
}

function Page({ url, shoppingCart }) {
  // 读取最新值
  const onVisit = useEventCallback(visitedUrl => {
    logVisit(visitedUrl, shoppingCart.length)
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // ✅ All dependencies declared 不需要添加shoppingCart依赖
}
```
