<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [性能优化](#性能优化)
  - [useMemo 缓存计算的结果](#usememo-缓存计算的结果)
  - [memo 跳过重新渲染](#memo-跳过重新渲染)
  - [useCallback 缓存函数](#usecallback-缓存函数)
    - [useCallback 与 useMemo 关系](#usecallback-与-usememo-关系)
    - [结合 memo](#结合-memo)
    - [作为子组件 props 的函数](#作为子组件-props-的函数)
    - [函数作为 useEffect 的依赖](#函数作为-useeffect-的依赖)
    - [函数被其他 hooks 依赖](#函数被其他-hooks-依赖)
  - [lazy 懒加载](#lazy-懒加载)
  - [useDeferredValue 延迟渲染](#usedeferredvalue-延迟渲染)
  - [useTransition 后台渲染部分 UI](#usetransition-后台渲染部分-ui)
    - [tab切换保持切换顺畅](#tab切换保持切换顺畅)
  - [useContext 跨组件传递数据](#usecontext-跨组件传递数据)
  - [useEffect 是一个 React Hook，它允许你 将组件与外部系统同步](#useeffect-是一个-react-hook它允许你-将组件与外部系统同步)
    - [定时器](#定时器)
    - [使用 Effect 请求数据](#使用-effect-请求数据)
  - [useReducer 状态管理](#usereducer-状态管理)
  - [ref 回调函数](#ref-回调函数)
    - [自动聚焦功能](#自动聚焦功能)

<!-- /code_chunk_output -->

# 性能优化

## useMemo 缓存计算的结果

- 用于优化性能，通过缓存计算结果来避免不必要的重复计算。

```tsx
const cachedValue = useMemo(calculateValue, dependencies)
```

```tsx
import { useMemo } from 'react';

function TodoList({ todos, tab }) {
  const visibleTodos = useMemo(
    () => filterTodos(todos, tab),
    [todos, tab]
  );
  // ...
}
```

## memo 跳过重新渲染

- 允许你的组件在 props 没有改变的情况下跳过重新渲染
- 记忆化只与从父组件传递给组件的 props 有关
- context 发生变化时，仍会重新渲染
- 自身的状态发生变化时，仍会重新渲染

```tsx
const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
```

```ts
import { memo } from 'react';

const SomeComponent = memo(function SomeComponent(props) {
  // ...
});
```

## useCallback 缓存函数

- 是一个允许你在多次渲染中缓存函数的 React Hook
- 不需要使用 useCallback
  - 普通事件处理函数（不传递给子组件）
  - 函数内部只使用 props 或 state
- 场景
  - 作为子组件 props 的函数 将其作为 props 传递给包装在 [memo] 中的组件
  - 函数作为 useEffect 的依赖,防止频繁触发 Effect 
  - 函数被其他 hooks 依赖
  - 自定义 Hook，建议将它返回的任何函数包裹在 useCallback
- 是否应该在任何地方添加 useCallback？
    - 尽可能缓存。不好的地方可能是降低了代码可读性

```tsx
// 是否需要 useCallback 的简单规则：

// 1. 这个函数会传递给子组件吗？
// 2. 这个函数会被其他 hooks 作为依赖使用吗？
// 3. 这个函数会在渲染期间频繁创建并影响性能吗？

// 如果答案都是"否"，就不需要 useCallback
const cachedFn = useCallback(fn, dependencies)
```

```tsx
import { useCallback } from 'react';

export default function ProductPage({ productId, referrer, theme }) {
  const handleSubmit = useCallback((orderDetails) => {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]);
```

### useCallback 与 useMemo 关系

- useMemo 经常与 useCallback 一同出现
  - useMemo 缓存函数调用的结果。
  - useCallback 缓存函数本身。不像 useMemo，它不会调用你传入的函数。相反，它缓存此函数。

```tsx
// 将 useCallback 视为
// 在 React 内部的简化实现
function useCallback(fn, dependencies) {
  return useMemo(() => fn, dependencies);
}
```

### 结合 memo

```tsx
import { memo } from 'react';

// onSubmit 不变，跳过渲染
const ShippingForm = memo(function ShippingForm({ onSubmit }) {
  // ...
});

// ❌ 每次渲染都创建新函数
function ProductPage({ productId, referrer, theme }) {
  // 每当 theme 改变时，都会生成一个不同的函数
  function handleSubmit(orderDetails) {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }
  
  return (
    <div className={theme}>
      {/* 这将导致 ShippingForm props 永远都不会是相同的，并且每次它都会重新渲染 */}
      {/* memo 对性能的优化永远不会生效 */}
      <ShippingForm onSubmit={handleSubmit} />
    </div>
  );
}

// ✅ 推荐 - 使用 useCallback 来缓存 handleSubmit 函数
function ProductPage({ productId, referrer, theme }) {
  // 在多次渲染中缓存函数
  const handleSubmit = useCallback((orderDetails) => {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]); // 只要这些依赖没有改变

  return (
    <div className={theme}>
      {/* ShippingForm 就会收到同样的 props 并且跳过重新渲染 */}
      <ShippingForm onSubmit={handleSubmit} />
    </div>
  );
}
```

### 作为子组件 props 的函数

```tsx
// ❌ 不推荐 - 每次渲染都创建新函数
function Parent() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    console.log('clicked');
  };
  
  return <Child onClick={handleClick} />; // 子组件会重新渲染
}

// ✅ 推荐 - 使用 useCallback
function Parent() {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <Child onClick={handleClick} />; // 子组件不会不必要重渲染
}
```

### 函数作为 useEffect 的依赖

```tsx
// ❌ 问题代码 - 无限循环
function Component() {
  const [data, setData] = useState([]);
  
  const fetchData = () => {
    // 获取数据逻辑
  };
  
  useEffect(() => {
    fetchData(); // fetchData 每次都是新函数，导致无限循环
  }, [fetchData]);
}

// ✅ 正确做法
function Component() {
  const [data, setData] = useState([]);
  
  const fetchData = useCallback(() => {
    // 获取数据逻辑
  }, []);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
}
```

### 函数被其他 hooks 依赖

```tsx
function Component() {
  const [value, setValue] = useState('');
  
  // 被 useMemo 依赖
  const processData = useCallback((data) => {
    return data.filter(item => item.includes(value));
  }, [value]);
  
  const processedData = useMemo(() => {
    return processData(rawData);
  }, [processData, rawData]);
}
```

## lazy 懒加载

- 能够让你在组件第一次被渲染之前延迟加载组件的代码
- 懒加载的 React 组件

```tsx
const SomeComponent = lazy(load)
```

```tsx
import { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

## useDeferredValue 延迟渲染

- 用于延迟渲染不紧急的UI更新，从而提高应用的响应性
- 使用场景
  - 基于输入值的计算
  - 简单的值延迟
  - 不需要复杂的加载状态控制
  - 自动优化现有组件
- 核心价值
  - 输入响应性优化 - 每次输入都触发搜索，即使输入很快
  - 防抖效果的自动实现

```tsx
const deferredValue = useDeferredValue(value)
```

```tsx
// query 会立即更新，所以输入框将显示新值。
// deferredQuery 在数据加载完成前会保留以前的值，因此 SearchResults 将暂时显示旧的结果。
// 不使用 deferredQuery 会导致输入卡顿
// React 正在渲染列表，但用户进行了另一次键盘输入，React 会放弃该重新渲染，先处理键盘输入，然后再次开始在后台渲染。
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  // 延迟获取最值，快速响应输入，如果多次输入，React 会放弃该重新渲染，先处理键盘输入
  const deferredQuery = useDeferredValue(query);
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={deferredQuery} />
      </Suspense>
    </>
  );
}
```

## useTransition 后台渲染部分 UI

- Transition 是非阻塞的，不会阻塞 UI 渲染
- 与 useDeferredValue的区别
  - useDeferredValue :自动延迟值的更新、被动延迟特定值、返回延迟后的值
  - useTransition : 手动标记状态更新为非紧急、主动包装更新逻辑、提供 isPending 状态
- 使用场景
  - 需要同时更新多个状态
  - 需要精确控制加载状态
  - 需要执行异步操作
  - 需要主动触发非紧急更新
- 独立的 startTransition 方法 ,它们的工作方式相同，但不提供 isPending 标记
- 核心价值
  - 保持UI响应性，大数据处理可能阻塞UI渲染
  - 处理大量数据的渲染
  - 用户交互优先级

```tsx
const [isPending, startTransition] = useTransition()
```

### tab切换保持切换顺畅

```tsx
// 不使用 useTransition 点击 posts 时会卡顿等待数据加载
// 使用 useTransition，点击后切换操作同步(顺畅)，UI等待数据加载完成后渲染
import { useState } from 'react';
import AboutTab from './AboutTab.js';
import PostsTab from './PostsTab.js';
import ContactTab from './ContactTab.js';
import { useTransition } from 'react';

export default function TabContainer() {
  const [tab, setTab] = useState('about');
  return (
    <>
      <TabButton
        isActive={tab === 'about'}
        action={() => setTab('about')}
      >
        About
      </TabButton>
      <TabButton
        isActive={tab === 'posts'}
        action={() => setTab('posts')}
      >
        Posts (slow)
      </TabButton>
      <TabButton
        isActive={tab === 'contact'}
        action={() => setTab('contact')}
      >
        Contact
      </TabButton>
      <hr />
      {tab === 'about' && <AboutTab />}
      {tab === 'posts' && <PostsTab />}
      {tab === 'contact' && <ContactTab />}
    </>
  );
}

function TabButton({ action, children, isActive }) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return <b>{children}</b>
  }
  if (isPending) {
    return <b className="pending">{children}</b>;
  }
  return (
    <button onClick={async () => {
       await action();
    }}>
      {children}
    </button>
  );
}

```

## useContext 跨组件传递数据

- 用于访问Context数据的Hook，它简化了跨组件传递数据的过程
- 与 createContext 配合使用

```tsx
const value = useContext(SomeContext)
```

```tsx
// 主题管理
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      <div className={`app-${theme}`}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};

// 使用
function App() {
  return (
    <ThemeProvider>
      <MyComponent />
    </ThemeProvider>
  );
}

function MyComponent() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <div className={`component-${theme}`}>
      <p>当前主题: {theme}</p>
      <button onClick={toggleTheme}>切换主题</button>
    </div>
  );
}
```

## useEffect 是一个 React Hook，它允许你 将组件与外部系统同步

- 在函数组件中执行副作用操作，如数据获取、订阅、手动DOM操作等

```tsx
useEffect(() => {
  // 副作用逻辑
  return () => {
    // 清理函数（可选）
  };
}, [dependencies]); // 依赖数组（可选）
```

### 定时器

```tsx
// 定时器
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // 清理定时器
    return () => {
      clearInterval(interval);
    };
  }, []);
  
  return <div>计时器: {seconds}秒</div>;
}
```

### 使用 Effect 请求数据

```tsx
// 确保 你的代码不会受到“竞争条件”的影响：网络响应可能会以与你发送的不同的顺序到达。
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);
  useEffect(() => {
    async function startFetching() {
      setBio(null);
      const result = await fetchBio(person);
      if (!ignore) {
        setBio(result);
      }
    }
    // 注意，ignore 变量被初始化为 false，并且在 cleanup 中被设置为 true。这样可以确保 你的代码不会受到“竞争条件”的影响：网络响应可能会以与你发送的不同的顺序到达。
    let ignore = false;
    startFetching();
    return () => {
      ignore = true;
    }
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}

```

## useReducer 状态管理

- 用于状态管理，特别适合处理复杂的状态逻辑

```tsx
const [state, dispatch] = useReducer(reducer, initialArg, init?)
```

```tsx
import { useReducer } from 'react';

// 定义reducer函数
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    default:
      throw new Error(`未知的action类型: ${action.type}`);
  }
}

// 初始状态
const initialState = { count: 0 };

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, initialState);
  
  return (
    <div>
      <p>计数: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>
        +1
      </button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>
        -1
      </button>
      <button onClick={() => dispatch({ type: 'RESET' })}>
        重置
      </button>
    </div>
  );
}
```

## ref 回调函数

- React 19 添加了 ref 回调的清理函数
- 允许我们在组件渲染时动态地获取DOM元素或组件实例的引用

```tsx
<div ref={(node) => {
  console.log('Attached', node);

  return () => {
    console.log('Clean up', node)
  }
}}>
```

### 自动聚焦功能

```tsx
function AutoFocusForm() {
  const [isVisible, setIsVisible] = useState(false);
  
  return (
    <div>
      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? '隐藏' : '显示'}表单
      </button>
      
      {isVisible && (
        <form style={{ marginTop: '10px', padding: '10px', border: '1px solid #ccc' }}>
          <div>
            <label>姓名:</label>
            <input 
              ref={(input) => {
                // 当元素挂载时自动聚焦
                if (input) {
                  input.focus();
                }
              }}
              type="text" 
              name="name" 
            />
          </div>
          
          <div style={{ marginTop: '10px' }}>
            <label>邮箱:</label>
            <input type="email" name="email" />
          </div>
        </form>
      )}
    </div>
  );
}
```
