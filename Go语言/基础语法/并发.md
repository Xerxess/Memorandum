<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [并发](#并发)
  - [核心组件](#核心组件)
- [Goroutine](#goroutine)
  - [处理Goroutine](#处理goroutine)
    - [sync.WaitGroup](#syncwaitgroup)
    - [Channel](#channel)
    - [Context](#context)
- [Channel](#channel-1)
  - [基本操作](#基本操作)
  - [无缓冲 Channel](#无缓冲-channel)
  - [有缓冲 Channel](#有缓冲-channel)
    - [for range](#for-range)
- [select](#select)
- [sync 包](#sync-包)
- [context 包](#context-包)
  - [创建新上下文](#创建新上下文)
  - [创建派生上下文](#创建派生上下文)
  - [上下文取消信号](#上下文取消信号)
  - [示例](#示例)
    - [发出取消 WithCancel](#发出取消-withcancel)
    - [发出取消提供错误信息 WithCancelCause](#发出取消提供错误信息-withcancelcause)
    - [基于时间的取消 WithTimeout、WithDeadline](#基于时间的取消-withtimeout-withdeadline)
    - [传递上下文值 WithValue](#传递上下文值-withvalue)

<!-- /code_chunk_output -->

# 并发

Go 的并发模型基于 CSP (Communicating Sequential Processes)，核心思想是：“不要通过共享内存来通信，而要通过通信来共享内存。”

## 核心组件

- Goroutine 是 Go 并发的核心。它是由 Go 运行时（Runtime）管理的轻量级线程。
  - 极轻量：初始栈空间仅 2KB（相比 OS 线程的数 MB）。
  - 高效调度：基于 G-M-P 模型，在多核 CPU 上实现成千上万个协程的并发执行。
- Channel (通道) Channel 是连接 Goroutine 的管道，用于安全地传递数据。
  - 无缓冲通道：保证同步，发送和接收必须同时就绪。
  - 有缓冲通道：允许异步，适合处理瞬时峰值流量。
- Select 语句
  - select 用于监听多个 Channel 的操作，是编写复杂并发逻辑（如超时控制、多路复用）的利器。
- Sync 包 (同步原语)
  - 追求极致性能或保护共享资源时，sync 包必不可少
  - sync.WaitGroup：等待一组 Goroutine 完成。
  - sync.Mutex / RWMutex：传统的互斥锁和读写锁。
  - sync.Once：确保某段代码（如单例初始化）仅执行一次。
  - sync.Pool：复用对象，极大减轻 2026 年高并发场景下的 GC 压力。
- Context (上下文控制)
  - 控制并发树的标准方式，用于取消信号和超时处理。
  - 场景：当一个 Web 请求被取消时，自动关闭该请求衍生出的所有数据库查询和下游 RPC 调用。

# Goroutine

Goroutine 最核心的杀手锏。它不是操作系统的“线程”，而是由 Go 运行时（Runtime）管理的用户态轻量级线程（也常被称为“协程”）。

- GMP 调度模型
  - G (Goroutine)：你通过 go 关键字开启的代码块。
  - M (Machine)：真正的操作系统线程（Worker Thread）。
  - P (Processor)：处理器（逻辑上下文）。它维护着一个本地 G 队列，负责将 G 分配给 M 执行。

```go
func main() {
 // 启动goroutine
 go func() {
    // 不执行的原因在于main提前结束了
  fmt.Println("This runs in a goroutine")
 }()

 fmt.Println("我是主程序，我不用等小明。")
}
```

```go
func main() {
 // 启动goroutine
 go func() {
  fmt.Println("This runs in a goroutine")
 }()

 fmt.Println("我是主程序，我不用等小明。")

 time.Sleep(500 * time.Millisecond)
 fmt.Println("干完活了，关门谢客。")
}
```

## 处理Goroutine

### sync.WaitGroup

```go
func waitGroup() {
 var wg sync.WaitGroup
 wg.Add(2)
 go func() {
  defer wg.Done() // 完成：走的时候登记一下
  fmt.Println("正在干活...")
  time.Sleep(time.Second)
 }()
 wg.Wait() // 阻塞：在这里等着，直到计数器变回 0
 fmt.Println("活干完了，主程序退出。")
}
```

### Channel

```go
func waitChannel() {
 done := make(chan bool) // 创建一个“信号灯”通道

 go func() {
  fmt.Println("waitChannel 正在干活...")
  time.Sleep(time.Second)
  done <- true // 干完活，发个信号
 }()

 <-done // 阻塞：一直等着信号出来，接到了才往下走
 fmt.Println("waitChannel 收到信号，活干完了。")
}
```

### Context

```go
func waitContext() {
 // 设置 2 秒后强制结束
 ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
 defer cancel()

 go func(ctx context.Context) {
  // 模拟耗时任务
  select {
  case <-time.After(1 * time.Second):
   fmt.Println("waitContext 任务正常完成")
  case <-ctx.Done():
   fmt.Println("waitContext 任务被取消或超时了")
  }
 }(ctx)

 <-ctx.Done() // 等待任务结束或超时
 fmt.Println("waitContext 活干完了。")
}
```

# Channel

- Channel（通道） 是连接多个 Goroutine 的管道。
- 它是 Go 语言并发设计的核心，体现了那句名言：“不要通过共享内存来通信，而要通过通信来共享内存。”

```go
var chan chan in
var chan <-chan in // 只读
var chan chan<- in // 只写
```

## 基本操作

- 创建：ch := make(chan int) (无缓冲) 或 ch := make(chan int, 10) (有缓冲)
- 发送数据：ch <- 100
- 接收数据：data := <-ch
- 关闭通道：close(ch)

## 无缓冲 Channel

- 称为同步通道
- 工作原理：发送者（Sender）和接收者（Receiver）必须同时准备好。如果没人接收，发送者就阻塞；如果没人发送，接收者就阻塞。

```go
// --- 无缓冲通道示例：强同步（当面签收） ---

// --- 开始演示：无缓冲 Channel ---
// [发送者] 准备发送快递...
// [接收者] 到了，准备签收。
// [接收者] 收到： 快递 A
// [发送者] 快递已被签收，任务完成！
func demoUnbuffered() {
 fmt.Println("--- 开始演示：无缓冲 Channel ---")
 ch := make(chan string)

 go func() {
  fmt.Println("  [发送者] 准备发送快递...")
  ch <- "快递 A" // 阻塞点：必须等接收者来拿，否则一直等在这里
  fmt.Println("  [发送者] 快递已被签收，任务完成！")
 }()

 time.Sleep(2 * time.Second) // 模拟接收者迟到 2 秒
 fmt.Println("[接收者] 到了，准备签收。")
 msg := <-ch
 fmt.Println("[接收者] 收到：", msg)
 time.Sleep(1 * time.Second) // 留一点时间看日志打印
}
```

## 有缓冲 Channel

- 称为异步通道
- 工作原理：内部维护一个环形队列（Ring Buffer）。只要缓冲区没满，发送者就不会阻塞；只要缓冲区不为空，接收者就不会阻塞。

```go
// --- 有缓冲通道示例：异步分发（快递柜） ---

// --- 开始演示：无缓冲 Channel ---
// [发送者] 准备发送快递 A...
// [接收者] 到了，从快递柜取件。
// [接收者] 收到： 快递 A
// [发送者] 准备发送快递 B...
// [发送者] 快递 A 和 B 都存好了，我下班了！
// [接收者] 收到： 快递 B
func demoBuffered() {
 fmt.Println("\n--- 开始演示：有缓冲 Channel (容量为 2) ---")
 ch := make(chan string)

 go func() {
  fmt.Println("  [发送者] 准备发送快递 A...")
  ch <- "快递 A" // 阻塞点：必须等接收者来拿，否则一直等在这里
  fmt.Println("  [发送者] 准备发送快递 B...")
  ch <- "快递 B" // 阻塞点：必须等接收者来拿，否则一直等在这里
  fmt.Println("  [发送者] 快递 A 和 B 都存好了，我下班了！")
 }()

 time.Sleep(2 * time.Second) // 模拟接收者迟到 2 秒
 fmt.Println("[接收者] 到了，从快递柜取件。")
 fmt.Println("[接收者] 收到：", <-ch)
 fmt.Println("[接收者] 收到：", <-ch)
}

// --- 开始演示：有缓冲 Channel (容量为 2) ---
// [发送者] 准备发送快递 A...
// [发送者] 准备发送快递 B...
// [发送者] 快递 A 和 B 都存好了，我下班了！
// [接收者] 到了，从快递柜取件。
// [接收者] 收到： 快递 A
// [接收者] 收到： 快递 B
func demoBuffered() {
 fmt.Println("\n--- 开始演示：有缓冲 Channel (容量为 2) ---")
 ch := make(chan string, 2)

 go func() {
  fmt.Println("  [发送者] 准备发送快递 A...")
  ch <- "快递 A" // 不阻塞：缓冲区没满，放进快递柜直接走人
  fmt.Println("  [发送者] 准备发送快递 B...")
  ch <- "快递 B" // 不阻塞：同上
  fmt.Println("  [发送者] 快递 A 和 B 都存好了，我下班了！")
 }()

 time.Sleep(2 * time.Second) // 模拟接收者迟到 2 秒
 fmt.Println("[接收者] 到了，从快递柜取件。")
 fmt.Println("[接收者] 收到：", <-ch)
 fmt.Println("[接收者] 收到：", <-ch)
}
```

### for range

- 需要明确 close(done)

```go
done := make(chan bool, 2) // 创建一个“信号灯”通道

go func() {
    fmt.Println("waitChannel 正在干活...")
    time.Sleep(time.Second * 2)
    fmt.Println("done <- true")
    done <- true // 干完活，发个信号

    time.Sleep(time.Second * 2)
    fmt.Println("done <- false")
    done <- false // 干完活，发个信号
    close(done) //注释此行 问题:fatal error: all goroutines are asleep - deadlock!
}()

time.Sleep(time.Second * 10)
fmt.Println("chanValue := range done")
for chanValue := range done {
    fmt.Println("chanValue " + strconv.FormatBool(chanValue))
}

fmt.Println("waitChannel 收到信号，活干完了。")
```

# select

专门用于同时监听多个 Channel 的操作，并在其中一个就绪时执行对应的代码块。

- select 会处理第一个准备就绪的接收
- 使用带有 default 子句的 select 来实现非阻塞的发送、接收，甚至是非阻塞的多路 select 操作。
- 配合for

```go
select {
    case msg1 := <-ch1:
        fmt.Println("接收到:", msg1)
    case ch2 <- "hello":
        fmt.Println("成功发送到 ch2")
    default:
        // 如果没有任何 case 就绪，执行这里（防止阻塞）
        fmt.Println("没有任何通道准备好")
}

select {
    case res := <-done:
        fmt.Println(res)
    case <-time.After(10 * time.Second): // ✅ 这里的定时器只会创建一次
        fmt.Println("超时退出")
}

for {
    case msg1 := <-ch1:
        fmt.Println("接收到:", msg1)
    case ch2 <- "hello":
        fmt.Println("成功发送到 ch2")
    default:
        // 如果没有任何 case 就绪，执行这里（防止阻塞）
        fmt.Println("没有任何通道准备好")
}
```

# sync 包

sync 包提供了基础的低级同步原语，用于协调多个 goroutine 对共享资源的访问。

- sync.Mutex (互斥锁)：最常用的同步原语。通过 Lock() 和 Unlock() 确保同一时刻只有一个协程能访问临界区。
- sync.RWMutex (读写锁)：允许多个协程同时读取，但只允许一个协程写入。适用于“读多写少”的场景。
- sync.WaitGroup：用于等待一组协程完成。主协程调用 Wait() 会阻塞，直到所有子协程执行 Done()。
  - Add(delta int)
  - Done()
  - Go(f func()) v1.25.0
  - Wait()
- sync.Once：确保某个操作在程序运行期间仅执行一次，常用于实现单例模式或初始化配置。
- sync.Pool (对象池)：用于缓存已分配但暂未使用的对象，减轻 GC（垃圾回收）压力。在高性能 Web 框架中广泛使用。
- sync.Cond (条件变量)：用于协程间的同步，当某个条件满足时通知一个或多个等待中的协程。

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var mu sync.Mutex
    var wg sync.WaitGroup
    counter := 0

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()   // 保护共享变量
            counter++
            mu.Unlock()
        }()
    }

    wg.Wait() // 等待所有协程结束
    fmt.Println("最终计数:", counter)
}
```

```go
// go1.25.0 支持Go(f func())
var wg sync.WaitGroup
wg.Go(func() {
    doWork() // Add(1) 和 Done() 会在底层自动处理
})
wg.Wait()


// 代码同上 显式创建的 goroutine 以及 Add 和 Done 函数
var wg sync.WaitGroup
wg.Add(1)
go func() {
 defer wg.Done()
 task1()
}()
wg.Add(1)
go func() {
 defer wg.Done()
 task2()
}()
wg.Wait()
```

# context 包

- context 包是处理并发控制、超时限制和跨 API 边界传递请求级数据的核心工具
- 使用 Context 的主要目的是以不浪费资源的方式管理长时间运行的进程（如 HTTP 请求 、数据库调用或网络调用）。
- 作用
  - 取消不再需要的长时间运行进程
  - 在函数调用之间传递请求范围的数据和取消信号
  - 为各项流程设定完成期限

## 创建新上下文

```go
// 返回一个新的空上下文实例，该实例没有任何关联的值。
ctx := context.Background()
```

## 创建派生上下文

- context.WithValue
- context.WithCancel
- context.WithDeadline

## 上下文取消信号

- context 包最常见的用途之一是在函数调用之间传播取消信号
- 常见情况：
  - (正常情况) HTTP 服务器向数据库发出请求，并将查询到的数据返回给客户端
  - (客户端在请求过程中取消) 停止进程下所有组件 (context的用途)

## 示例

### 发出取消 WithCancel

```go
func operation1(ctx context.Context) error {
 time.Sleep(100 * time.Millisecond)
 return errors.New("failed")
}

func operation2(ctx context.Context) {
 select {
 case <-time.After(500 * time.Millisecond):
  fmt.Println("done")
 case <-ctx.Done():
  fmt.Println("halted operation2")
 }
}

func main() {
 ctx := context.Background()
 // cancel 发出取消
 ctx, cancel := context.WithCancel(ctx)

 go func() {
  err := operation1(ctx)
  if err != nil {
   cancel()
  }
 }()

 operation2(ctx)
}
```

### 发出取消提供错误信息 WithCancelCause

```go
func operation1(ctx context.Context) error {
 time.Sleep(100 * time.Millisecond)
 return errors.New("failed")
}

func operation2(ctx context.Context) {
 select {
 case <-time.After(500 * time.Millisecond):
  fmt.Println("done")
 case <-ctx.Done():
    // 接收
    err := context.Cause(ctx)
  fmt.Println("halted operation2 due to error: ", err)
 }
}

func main() {
 ctx := context.Background()
 ctx, cancel := context.WithCancelCause(ctx)

 go func() {
  err := operation1(ctx)
  if err != nil {
    // 发出取消提供错误信息
   cancel(err)
  }
 }()

 operation2(ctx)
}
```

### 基于时间的取消 WithTimeout、WithDeadline

```go
// 上下文将在3秒后取消 基于超时
ctx, cancel := context.WithTimeout(ctx, 3*time.Second)

// 设置上下文截止日期 设置超时
ctx, cancel := context.WithDeadline(ctx, time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC))
```

```go
func main() {
 ctx := context.Background()
 ctx, _ = context.WithTimeout(ctx, 100*time.Millisecond)

 req, _ := http.NewRequest(http.MethodGet, "http://google.com", nil)
 req = req.WithContext(ctx)

 client := &http.Client{}
 res, err := client.Do(req)
 if err != nil {
  fmt.Println("Request failed:", err)
  return
 }

 fmt.Println("Response received, status code:", res.StatusCode)
}
```

### 传递上下文值 WithValue

```go
const keyID = "id"

func main() {
  rand.Seed(time.Now().Unix())
  requestID := rand.Intn(1000)

 ctx := context.WithValue(context.Background(), keyID, requestID)
 operation1(ctx)
}

func operation1(ctx context.Context) {
 log.Println("operation1 for id:", ctx.Value(keyID), " completed")
 operation2(ctx)
}

func operation2(ctx context.Context) {
 log.Println("operation2 for id:", ctx.Value(keyID), " completed")
}
```
