<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [迭代器](#迭代器)
  - [什么是迭代器](#什么是迭代器)
  - [标准类型 (iter 包)](#标准类型-iter-包)
  - [原理示例代码](#原理示例代码)
  - [strings 包迭代器（Iterator）函数](#strings-包迭代器iterator函数)
    - [strings.Lines：高效逐行处理](#stringslines高效逐行处理)
    - [strings.FieldsSeq：单词/字段提取](#stringsfieldsseq单词字段提取)
    - [strings.FieldsFuncSeq：自定义规则拆分](#stringsfieldsfuncseq自定义规则拆分)
    - [strings.SplitSeq 分隔符的拆分](#stringssplitseq-分隔符的拆分)
    - [strings.SplitAfterSeq：保留分隔符的拆分](#stringssplitafterseq保留分隔符的拆分)

<!-- /code_chunk_output -->

# 迭代器

Go 语言在 1.23 版本正式引入了基于函数的迭代器（Range-over-function）

## 什么是迭代器

- 迭代器本质上是一个符合特定签名的函数。它通过调用一个回调函数（通常命名为 yield）来“推送”数据。
  - 推模式 (Push Iterator)：迭代器控制执行流，将值传给 yield
  - 惰性求值：只有在循环需要下一个值时，迭代器才会生成它，这非常适合处理大数据集或无限序列（如斐波那契数列）。

## 标准类型 (iter 包)

- iter.Seq[V]：产生单个值的序列 func(yield func(V) bool)
- iter.Seq2[K, V]：产生键值对（如索引和值）的序列。 func(yield func(K, V) bool)

## 原理示例代码

```go
// AllNumbers 是生产者：它产生数据
func AllNumbers(n int) iter.Seq[int] {
 return func(yield func(int) bool) {
  fmt.Println("--- [迭代器内部] 开始生成数据 ---")
  
  for i := 1; i <= n; i++ {
   fmt.Printf("--- [迭代器内部] 准备推送数字: %d ---\n", i)
   
   // 调用 yield 将 i 发送给外部的 for range
   // 此时程序会跳转到 main 函数里的 fmt.Println 执行
   ok := yield(i) 
   
   fmt.Printf("--- [迭代器内部] 外部循环是否继续? %v ---\n", ok)
   
   if !ok {
    fmt.Println("--- [迭代器内部] 检测到外部 break，停止生成 ---")
    return
   }
  }
  
  fmt.Println("--- [迭代器内部] 数据全部生成完毕 ---")
 }
}

func main() {
 fmt.Println("[Main] 开始执行 for range")

// AllNumbers(3) 返回一个 iter.Seq[int]
// AllNumbers(3) 被调用，它返回一个闭包函数。
// for range 自动将循环体代码包装成一个名为 yield 的函数，并传入这个闭包。
// 此时，yield 函数逻辑等同于：func(v int) bool { 循环体代码; return true }。
 for v := range AllNumbers(3) {
  fmt.Printf("[Main 循环体] 接收到数字: %d\n", v)
  
  // 模拟一个提前跳出的场景
  if v == 2 {
   fmt.Println("[Main 循环体] 达到 2 了，我要 break")
   break
  }
 }

 fmt.Println("[Main] 运行结束")
}
```

## strings 包迭代器（Iterator）函数

- strings 包通过引入一系列迭代器（Iterator）函数，彻底改变了我们处理大文本的方式
- 无需一次性将所有数据加载到内存（如 strings.Split 会生成大量中间切片）

### strings.Lines：高效逐行处理

```go
// 假设 text 是从一个超大文件中读取的字符串
for line := range strings.Lines(text) {
    if strings.Contains(line, "ERROR") {
        fmt.Print(line) // line 自带换行符
    }
}
```

### strings.FieldsSeq：单词/字段提取

类似于 strings.Fields，它会根据空白字符（空格、制表符等）分割字符串，但返回的是迭代器。它会自动忽略连续的空白字符，不会产生空字符串。

```go
text := "  The   quick brown fox  "
for word := range strings.FieldsSeq(text) {
    fmt.Printf("[%s] ", word) // 依次输出 "The", "quick", "brown", "fox"
}
```

### strings.FieldsFuncSeq：自定义规则拆分

```go
// 根据所有非字母字符拆分
f := func(c rune) bool { return !unicode.IsLetter(c) }
for part := range strings.FieldsFuncSeq("Go1.24;Iterators:Great", f) {
    fmt.Println(part) // 输出 "Go", "Iterators", "Great"
}
```

### strings.SplitSeq 分隔符的拆分

```go
// 即使 data 是 10GB 的内容
 data := "very_large_data_..." 

 // SplitSeq 不会立即分割字符串，它只返回一个“迭代器”
 // 此时并没有发生大规模内存分配
 it := strings.SplitSeq(data, ",")

 // 只有在循环开始执行时，它才寻找下一个逗号
 for part := range it {
  // 每次循环只处理当前这一小段字符串
  // 处理完后，内存可以被复用或回收
  fmt.Println(part)
  
  // 如果执行到这里 break，迭代器就停止扫描
  // 后面的 9GB 数据完全不会被触碰
  break 
 }
```

### strings.SplitAfterSeq：保留分隔符的拆分

与 SplitSeq 不同，它在分割时会保留分隔符本身

如：SplitAfterSeq("a,b,c", ",") 会依次产出 "a,", "b,", "c"。
