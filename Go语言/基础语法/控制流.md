<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [控制流](#控制流)
  - [if](#if)
  - [for](#for)
  - [switch](#switch)

<!-- /code_chunk_output -->

# 控制流

## if

- Go 没有三目运算符，所以不支持 ?: 形式的条件判断。

```go
// 基础if语句
if x > 0 {
    return y
}

// 带有初始化语句的if
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}


// 省略else的写法（常见错误处理模式）
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)


// 链式错误处理
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

## for

```go
// 经典的循环
for i := 0; i < 5; i++ {
    fmt.Println(i)
}

```

```go
// 类似 While 风格
n := 1
for n < 100 {
    n *= 2
}
```

```go
// 常用于后台常驻服务、服务器监听。
for {
    // 除非 break 或 return，否则永远执行
}
```

```go
// 用于遍历数组、切片、字符串、Map 或 Channel。
nums := []int{10, 20, 30}
for index, value := range nums {
    fmt.Printf("索引: %d, 值: %d\n", index, value)
}
```

```go
// 配合 Select 监听（For-Select 模式）
// 这是 Go 并发编程的标准模版，用于持续处理多个通道的消息。
for {
    select {
    case msg := <-ch:
        fmt.Println("处理任务:", msg)
    case <-ctx.Done():
        fmt.Println("停止信号已到，退出循环")
        return // 退出函数
    }
}
```

```go
// 标签（Label
OuterLoop:
for i := 0; i < 5; i++ {
    for j := 0; j < 5; j++ {
        if i*j > 6 {
            break OuterLoop // 直接跳出最外层循环
        }
    }
}
```

## switch

- switch 是替代复杂 if-else 链的首选方案
- Go 的 switch 每个 case 执行完后会自动跳出，不需要手动写 break。

```go
finger := 3
switch finger {
    case 1:
        fmt.Println("大拇指")
    case 2:
        fmt.Println("食指")
    case 3:
        fmt.Println("中指") // 匹配后执行，然后直接结束 switch
    default:
        fmt.Println("无效的数值")
}
```

```go
// 无表达式 switch (替代 if-else)
// 不提供 switch 后的变量，它就相当于判断 true。这比嵌套的 if-else 更加整洁。
score := 85
switch {
case score >= 90:
    fmt.Println("优秀")
case score >= 80:
    fmt.Println("良好")
default:
    fmt.Println("一般")
}
```

```go
// 一分支多匹配
letter := "i"
switch letter {
    case "a", "e", "i", "o", "u":
        fmt.Println("这是元音")
    default:
        fmt.Println("这是辅音")
}
```

```go
// Type Switch (类型断言)
func printType(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s\n", v)
    case bool:
        fmt.Printf("布尔值: %v\n", v)
    default:
        fmt.Println("未知类型")
    }
}
```
