<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [闭包](#闭包)
  - [循环依赖](#循环依赖)
    - [可能产生内存泄漏](#可能产生内存泄漏)

<!-- /code_chunk_output -->

# 闭包

函数可以作为变量传递，也可以在函数内部定义并访问外部变量（闭包）。

```go
func main() {
    // 匿名函数
    fn := func(msg string) {
        fmt.Println(msg)
    }
    fn("Hello Go 2026")

    // 闭包：累加器
    gen := func() func() int {
        i := 0
        return func() int {
            i++
            return i
        }
    }
    next := gen()
    fmt.Println(next()) // 1
    fmt.Println(next()) // 2
}
```

## 循环依赖

- 底层内存管理机制（垃圾回收/GC）与 Swift（自动引用计数/ARC）有本质区别
  - Swift (ARC)：通过计算对象的引用次数来管理内存。如果对象 A 强引用了闭包，而闭包又捕获并强引用了 A，引用计数永远无法归零，导致内存泄漏（必须使用 weak 或 unowned 破解）。
  - Go (GC)：采用可达性分析算法（Mark-and-Sweep）。垃圾回收器从根对象（如栈、全局变量）开始扫描。即便两个对象互相引用（循环引用），只要它们与根节点断开了联系，GC 就会识别出它们是“不可达”的，从而一次性全部回收。
- Go 几乎不会产生由于闭包导致的循环引用（Circular Reference）内存泄漏。

### 可能产生内存泄漏

```go
func heavyLogic() func() {
    hugeData := make([]byte, 100 * 1024 * 1024) // 100MB
    return func() {
        fmt.Println(len(hugeData)) // 只要这个闭包还在，hugeData 就永远不会被回收
    }
}
```
