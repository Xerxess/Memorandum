
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [泛型](#泛型)
  - [命名规范](#命名规范)
  - [语法](#语法)
    - [多个泛型的基本语法](#多个泛型的基本语法)
    - [泛型函数](#泛型函数)
    - [泛型结构体](#泛型结构体)
    - [泛型自定义类型](#泛型自定义类型)
    - [泛型接口](#泛型接口)
  - [类型约束](#类型约束)
    - [any 约束](#any-约束)
    - [comparable 约束](#comparable-约束)
    - [自定义接口约束](#自定义接口约束)
  - [类型集 (Type Sets)](#类型集-type-sets)
  - [泛型类型](#泛型类型)

<!-- /code_chunk_output -->

# 泛型

- 在 Go 1.18 版本（2022年发布）正式引入
- 允许编写可以处理多种类型的函数和数据结构。

## 命名规范

- 命名规范：虽然习惯用 T、V、K 等单字母，但在多个泛型较多时，建议使用语义化的名字（以大写开头），如 [Source any, Target any]，这在 Go 1.26 的大型项目中已成为推荐实践。

## 语法

### 多个泛型的基本语法


```go
func MyFunc[T any, K comparable, V any](arg1 T, arg2 K, arg3 V) {
    // T、K、V 是三种可能不同、也可能相同的类型
}
```

### 泛型函数

```go
// T 是类型参数，any 是约束（表示可以是任何类型）
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Println(v)
    }
}
```

### 泛型结构体

```go
type Node[T any] struct {
    Data T
    Next *Node[T]
}
```

### 泛型自定义类型

```go
type List[T any] []T
type Dictionary[K comparable, V any] map[K]V
```

### 泛型接口

```go
type Getter[T any] interface {
    Get() T
}
```

## 类型约束

```go
// 定义一个约束，只允许 int 或 float64
type Number interface {
    int | float64
}

func Sum[T Number](a, b T) T {
    return a + b
}
```

### any 约束

- any 是 interface{}（空接口）的别名 (Go 1.18)
- 含义：代表“任何类型”。没有任何方法限制，任何类型都满足此约束。
- 适用场景：当你对泛型参数的具体操作不依赖其类型特性（如：只是搬运数据、打印、存储到容器）时使用。

```go
// 这里的 T 只要是 Go 里的类型就行，没有任何限制
func Swap[T any](a, b *T) {
    *a, *b = *b, *a
}
```

### comparable 约束

- comparable 是一个内置的特殊接口，它约束类型必须支持 相等性比较（即可以使用 == 和 != 运算符）。

```go
// T 必须是可比较的，否则无法执行 v == target
func Contains[T comparable](slice []T, target T) bool {
    for _, v := range slice {
        if v == target { // 只有 comparable 类型才能用 ==
            return true
        }
    }
    return false
}
```

### 自定义接口约束

```go
type Number interface {
    ~int | ~float64 | ~int64  // 允许这些类型及其衍生类型
}
```

## 类型集 (Type Sets)

- 使用 | 表示并集
- 使用 ~ 前缀（如 ~int）表示包含所有底层类型为 int 的类型（即支持 type MyInt int）。

## 泛型类型

```go
// 除了函数，结构体、切片和映射也可以是泛型的。
type Stack[T any] struct {
    elements []T
}

func (s *Stack[T]) Push(v T) {
    s.elements = append(s.elements, v)
}
```
