<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [字符串](#字符串)
  - [操作](#操作)
    - [字符串遍历](#字符串遍历)
    - [字符串插值](#字符串插值)
    - [字符串长度](#字符串长度)
    - [字符串分割](#字符串分割)
    - [插入和删除](#插入和删除)
    - [前缀与后缀](#前缀与后缀)
    - [访问与修改字符串](#访问与修改字符串)
  - [常用标准库推荐](#常用标准库推荐)
  - [strings 包](#strings-包)
  - [fmt 包](#fmt-包)

<!-- /code_chunk_output -->

# 字符串

Go 的字符串索引是基于字节的。如果要精确处理“字符”，请将字符串转换为 []rune
支持反引号``

```go
// 解释型字符串字面量
s := "Go语言"

// 1. 使用 byte 遍历 (底层 UTF-8 编码)
fmt.Println(len(s)) // 输出: 8 (G=1, o=1, 语=3, 言=3)

// 2. 错误的索引访问
fmt.Printf("%c\n", s[2]) // 输出乱码，因为只取到了“语”字的第一个字节

// 3. 使用 rune 遍历
runes := []rune(s)
fmt.Println(len(runes))      // 输出: 4 (G, o, 语, 言)
fmt.Printf("%c\n", runes[3]) // 输出: 语 (正确)

// 使用utf8 获取字符串长度
utf8.RuneCountInString("Go语言") // 返回 4

// 反引号 原始字符串字面量
`abc`                // same as "abc"

// 多行
`\n
\n`                  // same as "\\n\n\\n"
```

## 操作

### 字符串遍历

```go
// 0 你
// 3 好
// 6 ,
// 7 H
// 8 e
// 9 l
// 10 l
// 11 o
// 12  
// 13 W
// 14 o
// 15 r
// 16 l
// 17 d
for i, r := range "你好,Hello World" {
    fmt.Printf("%v %c\n", i, r)
}


// 0 你
// 1 好
// 2 ,
// 3 H
// 4 e
// 5 l
// 6 l
// 7 o
// 8  
// 9 W
// 10 o
// 11 r
// 12 l
// 13 d
for i, v := range []rune("你好,Hello World") {
    fmt.Println(i, string(v))
}
```

### 字符串插值

```go
// 简单的拼接 +
name := "go" + "go"

// fmt.Sprintf
name := "Go"
s := fmt.Sprintf("Hello, %s!", name) // 支持多种占位符

// 高性能（预定义模板）：text/template

// 
```

### 字符串长度

```go
s := "Go语言"
fmt.Println(len(s)) // 输出: 8 (G, o 占2字节，两个汉字各占3字节)

count := utf8.RuneCountInString("Go语言") // 输出: 4
```

### 字符串分割

```go
// 将字符串转为切片
strings.Split("abc,abc,abc",",")
```

### 插入和删除

```go
s := "Hello World"
// 在位置 5 插入 "Go"
res := s[:5] + "Go" + s[5:] 

// 删除位置 5 之后的 6 个字符
res := s[:5] + s[11:]
```

### 前缀与后缀

```go
import "strings"

s := "main.go"
hasPrefix := strings.HasPrefix(s, "main") // true
hasSuffix := strings.HasSuffix(s, ".go")   // true
```

### 访问与修改字符串

- 注意：如果是修改其中的中文，必须转为 []rune

```go
// 按字节访问：b := s[i] (返回 byte)。
// 按字符访问：使用 for range 或转为 []rune(s) 后按索引访问。
// 注意：如果是修改其中的中文，必须转为 []rune
s := "你好,Hello World"
fmt.Println(string(s[0]))
bb := []byte(s)
bb[0] = 'C'
s = string(bb)
fmt.Println(s) // C��好,Hello World

s = "你好,Hello World"
cc := []rune(s)
cc[0] = 'C'
s = string(cc)
fmt.Println(s) // C好,Hello World
```

## 常用标准库推荐

- strings：提供 Contains, Join, ReplaceAll, Split, HasPrefix 等。
- strconv：用于字符串与基本数据类型（int, float, bool）的相互转换。
- unicode/utf8：用于处理底层的 UTF-8 校验与计数。

## strings 包

```go
p("Contains:  ", s.Contains("test", "es")) // true
p("Count:     ", s.Count("test", "t")) // 2
p("HasPrefix: ", s.HasPrefix("test", "te")) // true
p("HasSuffix: ", s.HasSuffix("test", "st")) // true
p("Index:     ", s.Index("test", "e")) // 1
p("Join:      ", s.Join([]string{"a", "b"}, "-")) // a-b
p("Repeat:    ", s.Repeat("a", 5)) // aaaaa
p("Replace:   ", s.Replace("foo", "o", "0", -1)) // f00
p("Replace:   ", s.Replace("foo", "o", "0", 1)) // f0o
p("Split:     ", s.Split("a-b-c-d-e", "-")) // [a b c d e]
p("ToLower:   ", s.ToLower("TEST")) // test
p("ToUpper:   ", s.ToUpper("test")) // TEST
```

## fmt 包

```go
p := point{1, 2}
fmt.Printf("struct1: %v\n", p) // {1 2}

// 如果该值是一个结构体，则 %+v 变体将包含该结构体的字段名称。
fmt.Printf("struct2: %+v\n", p) // {x:1 y:2}

// %#v 变体打印该值的 Go 语法表示，即生成该值的源代码片段。
fmt.Printf("struct3: %#v\n", p) // main.point{x:1, y:2}

// 要打印值的类型，请使用 %T 。
fmt.Printf("type: %T\n", p) // main.point

// 格式化布尔值很简单。
fmt.Printf("bool: %t\n", true) // true

// 整数的格式化方式有很多种。使用 %d 可以实现标准的十进制格式化。
fmt.Printf("int: %d\n", 123) // 123

// 这将输出二进制表示。
fmt.Printf("bin: %b\n", 14) // 1110

// 此命令会打印出与给定整数对应的字符。
fmt.Printf("char: %c\n", 33) // !

// %x 提供十六进制编码。
fmt.Printf("hex: %x\n", 456) // 1c8

// 浮点数也有几种格式化选项。要进行基本的十进制格式化，请使用 %f 。
fmt.Printf("float1: %f\n", 78.9) // 78.900000

// %e 和 %E 将浮点数格式化为（略有不同的）科学计数法。
fmt.Printf("float2: %e\n", 123400000.0) // 1.234000e+08
fmt.Printf("float3: %E\n", 123400000.0) // 1.234000E+08

// 要进行基本的字符串打印，请使用 %s 。
fmt.Printf("str1: %s\n", "\"string\"") // "string"

// 要像 Go 源代码那样对字符串进行双引号括起来，请使用 %q 。
fmt.Printf("str2: %q\n", "\"string\"") // "\"string\""

// 与前面看到的整数一样， %x 以 16 进制渲染字符串，每个输入字节输出两个字符。
fmt.Printf("str3: %x\n", "hex this") // 6865782074686973

// 要打印指针的表示形式，请使用 %p 。
fmt.Printf("pointer: %p\n", &p) // 0xc0000ba000

// 格式化数字时，您通常需要控制结果数字的宽度和精度。要指定整数的宽度，请在动词中的 % 后添加一个数字。默认情况下，结果将右对齐并用空格填充。
fmt.Printf("width1: |%6d|%6d|\n", 12, 345) // |    12|   345|

// 您还可以指定打印浮点数的宽度，不过通常您还需要同时使用 width.precision 语法限制小数精度。
fmt.Printf("width2: |%6.2f|%6.2f|\n", 1.2, 3.45) // |  1.20|  3.45|

// 要左对齐，请使用 - 标志。
fmt.Printf("width3: |%-6.2f|%-6.2f|\n", 1.2, 3.45) // |1.20  |3.45  |

// 您在格式化字符串时可能还需要控制宽度，尤其是在确保字符串在类似表格的输出中对齐时。基本的右对齐宽度如下：
fmt.Printf("width4: |%6s|%6s|\n", "foo", "b") // |   foo|     b|

// 要左对齐，请使用 - 标志，就像使用数字一样。
fmt.Printf("width5: |%-6s|%-6s|\n", "foo", "b") // |foo   |b     |

// 到目前为止，我们已经了解了 Printf ，它会将格式化后的字符串打印到 os.Stdout Sprintf 则会格式化并返回一个字符串，而不会将其打印到任何地方。
s := fmt.Sprintf("sprintf: a %s", "string") // a string
fmt.Println(s)

// 您可以格式化并打印到除 io.Writers 以外的其他 io.Writer。 使用 Fprintf 输出 os.Stdout 。
fmt.Fprintf(os.Stderr, "io: an %s\n", "error") // io: an error
```
