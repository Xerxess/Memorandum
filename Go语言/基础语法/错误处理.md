<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [错误处理](#错误处理)
  - [自定义错误类型](#自定义错误类型)
  - [基础错误包](#基础错误包)

<!-- /code_chunk_output -->

# 错误处理

- Go 不使用 try-catch 异常机制
- Go使用返回值处理错误，显式地返回并处理错误
- Go 的错误处理比较冗长（到处是 if err != nil），但它强制开发者在错误发生的地方进行思考，极大地提高了代码的健壮性和可维护性。

```go
func DoSomething() (int, error) {
    if fail {
        return 0, errors.New("操作失败") // 创建简单错误
    }
    return 42, nil // 成功时返回 nil
}

// 调用处
result, err := DoSomething()
if err != nil {
    // 立即处理错误，通常是向上返回或记录日志
    return fmt.Errorf("调用失败: %w", err) 
}
```

## 自定义错误类型

```go
type MyError struct {
    Code    int
    Message string
}

// 必须实现 Error() 接口
func (e *MyError) Error() string {
    return fmt.Sprintf("Code: %d, Msg: %s", e.Code, e.Message)
}

func f(arg int) (int, error) {
    if arg == 42 {
        return -1, &MyError{arg, "can't work with it"}
    }
    return arg + 3, nil
}

	
func main() {
    _, err := f(42)
    var ae *MyError
    if errors.As(err, &ae) {
        fmt.Println(ae.Code)
        fmt.Println(ae.Message)
    } else {
        fmt.Println("err doesn't match argError")
    }
}
```

## 基础错误包

```go
// `New` 方法返回一个格式为给定文本的错误信息
// 创建基础错误
func New(text string) error
var ErrNotFound = errors.New("item not found")

// 函数会在错误树中查找第一个与目标匹配的错误，如果找到，则将目标设置为该错误值并返回 true；否则，返回 false。
// 类型提取（类型转换）
// 使用场景：需要获取错误对象中的具体字段时
func As(err error, target any) bool

// err 中是否存在与目标匹配的错误
// 逻辑判等（相等性检查）
func Is(err, target error) bool

// Join 函数返回一个包含给定错误的字符串
// 聚合多个错误 (Go 1.20+)
func Join(errs ...error) error

// 解包错误
// 特点：通常开发者很少直接调用 Unwrap，而是通过 Is 或 As 间接使用。
func Unwrap(err error) error
```
