<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [函数](#函数)
  - [基础语法](#基础语法)
  - [多返回值](#多返回值)
  - [命名返回值](#命名返回值)
  - [可变参数](#可变参数)
  - [defer语句](#defer语句)

<!-- /code_chunk_output -->

# 函数

- Go函数支持多返回值,这是处理错误和额外信息的惯用方式

## 基础语法

```go
// 基础格式：func 函数名(参数名 参数类型) 返回值类型
func add(a int, b int) int {
    return a + b
}

// 同类型参数可简写
func multiply(a, b int) int {
    return a * b
}
```

## 多返回值

- Go 函数支持返回多个值，这通常用于返回 “结果 + 错误”，彻底取代了其他语言中的 try-catch 异常机制。

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("除数不能为零")
    }
    return a / b, nil
}

// 调用时处理
res, err := divide(10, 0)
if err != nil {
    fmt.Println("发生错误:", err)
    return
}
```

## 命名返回值

- 在函数头部直接定义返回变量的名字，它们会被初始化为零值，并在只写 return 时自动返回

```go
func getRect(width, height int) (area, perimeter int) {
    area = width * height
    perimeter = (width + height) * 2
    return // 自动返回 area 和 perimeter
}
```

## 可变参数

- 使用 ... 表示可以传入任意数量的同类型参数。

```go
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}
// 调用方式：sum(1, 2, 3, 4)
```

## defer语句

- 这是 defer 最常见的场景。紧跟在资源打开语句之后，确保函数结束时自动关闭资源，防止内存或文件句柄泄露。

```go
func readFile(filename string) {
    f, err := os.Open(filename)
    if err != nil {
        return
    }
    // 确保在 readFile 函数退出前执行关闭操作
    defer f.Close() 

    // 进行文件读取操作...
}

func multiDefer() {
    defer fmt.Println("第一步")
    defer fmt.Println("第二步")
    defer fmt.Println("第三步")
}
// 输出顺序：
// 第三步
// 第二步
// 第一步
```
