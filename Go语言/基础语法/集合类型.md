<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [集合类型](#集合类型)
  - [数组和切片](#数组和切片)
    - [数组](#数组)
    - [切片](#切片)
  - [Map](#map)

<!-- /code_chunk_output -->

# 集合类型

## 数组和切片

- 数组是固定长度的同类型元素序列
- 切片是数组的动态视图

### 数组

- 不支持添加元素
- 不支持删除元素
- 复制 a = b 直接拷贝整个数值
- 获取长度 len(arr)
- 获取容量 cap(arr) (恒等于长度)

```go
// 数组声明（长度是类型的一部分）
var arr1 [5]int              // [0 0 0 0 0]
arr2 := [3]int{1, 2, 3}      // [1 2 3]
arr3 := [...]int{4, 5, 6}    // 编译器推断长度 [4 5 6]
arr4 := [5]int{0: 10, 2: 20} // [10 0 20 0 0] 指定索引初始化

// 二维数组
matrix := [3][3]int{
    {1, 0, 0},
    {0, 1, 0},
    {0, 0, 1},
}

// 遍历数组
fmt.Print("Array: ")
for i, v := range arr2 {
    fmt.Printf("[%d]=%d ", i, v)
}
fmt.Println()

// 多维数组遍历
for i, row := range matrix {
    for j, v := range row {
        fmt.Printf("matrix[%d][%d] = %d ", i, j, v)
    }
    fmt.Println()
}
```

### 切片

- 添加元素 使用 append() 动态添加
- 删除元素 通过切片表达式重组实现
- 复制 使用 copy() 函数拷贝底层数据
- 获取长度 len(slc)
- 获取容量 cap(slc) (可能大于长度)

```go
// 切片声明
var slice1 []int             // nil切片
slice2 := []int{1, 2, 3, 4}  // 字面量初始化
slice3 := make([]int, 5)     // [0 0 0 0 0]
slice4 := make([]int, 3, 10) // 长度3，容量10

// 切片操作
fmt.Printf("Slice len: %d, cap: %d\n", len(slice4), cap(slice4))
```

```go
// 切片截取 (Reslicing)
data := []int{0, 1, 2, 3, 4, 5}
fmt.Println(data[1:4]) // [1 2 3]
fmt.Println(data[:3])  // [0 1 2] (从头开始)
fmt.Println(data[3:])  // [3 4 5] (直到最后)

// append操作
slice2 = append(slice2, 5, 6)
fmt.Printf("After append: %v\n", slice2)

// 删除索引为 i 的元素
i := 2
s := []int{0, 1, 2, 3, 4}
s = append(s[:i], s[i+1:]...) // 结果: [0 1 3 4]

// 复制切片 (Copy)
src := []int{1, 2, 3}
dst := make([]int, len(src))
copy(dst, src) // 将 src 的内容复制到 dst
```

## Map

- Map（映射/字典）是一种内置的引用类型数据结构，用于存储无序的 键值对 (Key-Value pairs)。
- 它基于哈希表实现，提供平均 \(O(1)\) 时间复杂度的查找、插入和删除性能。

```go
// 1. 初始化 (推荐使用 make 以指定初始容量 hint，提高性能)
m := make(map[string]int, 10) 

// 2. 字面量初始化
ages := map[string]int{
    "Alice": 25,
    "Bob":   30,
}

// 3. 增加或修改元素
m["key1"] = 100 

// 4. 获取元素（双值返回，防范键不存在）
val, ok := m["key1"] 
if ok {
    fmt.Println("值存在:", val)
}

// 5. 删除元素
delete(m, "key1") 

// 6. 获取长度（键值对数量）
length := len(m) 

// 7. 遍历 Map
for k, v := range m {
    fmt.Printf("键: %v, 值: %v\n", k, v)
}
```
