<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [接口](#接口)
  - [空接口](#空接口)
  - [类型断言](#类型断言)
  - [示例代码](#示例代码)

<!-- /code_chunk_output -->


# 接口

- 接口是Go实现多态的主要机制。类型通过实现接口的所有方法来实现接口，无需显式声明。
- Go的接口是鸭子类型（duck typing）的实现。
- any 是 interface{}（空接口）的别名 (Go 1.18)

```go
// 定义接口
type Shaper interface {
    Area() float64
}

type Square struct {
    side float64
}

// Square 实现了 Area 方法，所以它自动实现了 Shaper 接口
func (s Square) Area() float64 {
    return s.side * s.side
}
```

## 空接口

- any 是 interface{}（空接口）的别名 (Go 1.18)
- 空接口 interface{} 是 Go 的特殊接口，表示所有类型的超集。
- 任意类型都实现了空接口。
- 常用于需要存储任意类型数据的场景，如泛型容器、通用参数等。

```go
package main

import "fmt"

func printValue(val interface{}) {
        fmt.Printf("Value: %v, Type: %T\n", val, val)
}

func main() {
        printValue(42)         // int
        printValue("hello")    // string
        printValue(3.14)       // float64
        printValue([]int{1, 2}) // slice
}
```

## 类型断言

```go
// iface 是接口变量。
// Type 是要断言的具体类型。
// 如果类型不匹配，会触发 panic。
// ok 是一个布尔值，表示断言是否成功。
value := iface.(Type)
value, ok := iface.(Type)
```

```go
var s Speaker = Dog{}
// 断言 s 是否为 Dog 类型
d, ok := s.(Dog) 
if ok {
    fmt.Println("这是一个 Dog 类型")
}
```

## 示例代码

```go
// 定义接口
type Payer interface {
    Pay(amount float64) error
}

// 微信支付
type WeChat struct {
    UId string
}
func (w WeChat) Pay(amount float64) error {
    fmt.Printf("微信用户 %s 支付了 %.2f 元\n", w.UId, amount)
    return nil
}

// 支付宝支付
type AliPay struct {
    Account string
}
func (a AliPay) Pay(amount float64) error {
    fmt.Printf("支付宝账号 %s 支付了 %.2f 元\n", a.Account, amount)
    return nil
}

func Checkout(p Payer, amount float64) {
    // 逻辑：不管你是微信还是支付宝，我只管调用你的 Pay 方法
    err := p.Pay(amount)
    if err != nil {
        fmt.Println("支付失败")
        return
    }
    fmt.Println("支付成功，准备发货！")
}

func main() {
    wechat := WeChat{UId: "wx_123"}
    alipay := AliPay{Account: "abc@example.com"}

    // 同样一个 Checkout 函数，可以接收不同的类型
    Checkout(wechat, 100.50)
    Checkout(alipay, 200.00)
}

```
