<!-- TOC -->

- [require.context](#requirecontext)
- [分片](#分片)
    - [延迟加载](#延迟加载)
    - [SplitChunksPlugin](#splitchunksplugin)
    - [MinChunkSizePlugin](#minchunksizeplugin)
    - [SplitChunksPlugin](#splitchunksplugin-1)
        - [cacheGroups](#cachegroups)
    - [捆绑分析](#捆绑分析)
- [自动加载](#自动加载)
    - [ProvidePlugin](#provideplugin)

<!-- /TOC -->

# require.context

```js
// 加载./components 下的所有组件
const context = require.context('./components', true, /\.vue/);
let components = {};
context.keys().forEach((item) => {
  components[item.split('/')[1]] = context(item).default;
});
```

# 分片

## 延迟加载

https://v4.webpack.js.org/guides/lazy-loading/

```js
import(/* webpackChunkName: "print" */ './print').then((module) => {
  const print = module.default;
  print();
});
```

## SplitChunksPlugin

```js
//webpack.config.js
  {
     optimization: {
     splitChunks: {
       chunks: 'all',
     }
   }
  }
```

## MinChunkSizePlugin

- 通过合并小于的块，使块大小保持在指定限制以上

```js
plugins: [
  new webpack.optimize.MinChunkSizePlugin({
    minChunkSize: 100000,
  }),
];
```

## SplitChunksPlugin

https://www.cnblogs.com/kwzm/p/10314438.html

* 开箱即用
* 可以共享新块，或者模块来自node_modules文件夹
* 新的块将大于30kb（在min + gz之前）
* 按需加载块时并行请求的最大数量将小于或等于5
* 初始页面加载时并行请求的最大数量将小于或等于3
```js
// default
module.exports = {
  //...
  optimization: {
    splitChunks: {
      // 有效值为all，async和initial
      // initial:只从入口模块进行拆分
      // async:表示只从异步加载得模块（动态加载import()）里面进行拆分
      // all:异步和非异步块之间也可以共享块
      // chunks (chunk) {
      //   return chunk.name !== 'my-excluded-chunk';
      // }
      chunks: 'async',

      // 生成块的最小大小（以字节为单位）
      minSize: 30000,
      maxSize: 0,

      // 拆分前必须共享模块的最小块数(被引用的最小次数)
      minChunks: 1,

      // 按需加载时的最大并行请求数
      // 理解为是每个import()它里面的最大并行请求数量
      maxAsyncRequests: 5,
      
      // 入口点的最大并行请求数
      maxInitialRequests: 3,
      
      automaticNameDelimiter: '~',
      automaticNameMaxLength: 30,

      // 拆分块的名称
      // true将基于块和缓存组密钥自动生成一个名称
      // 提供字符串或函数使您可以使用自定义名称
      name: true,
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10
        },
        default: {
          minChunks: 2,
          // 权重设置
          priority: -20,

          // 如果当前块包含已从主捆绑包中拆分出的模块，则它将被重用，而不是生成新的模块。
          reuseExistingChunk: true
        }
      }
    }
  }
};
```

### cacheGroups

```js
module.exports = {
  optimization: {
    splitChunks: {
      // cacheGroups
      cacheGroups: {
        vendors: {
          // 如果当前块包含已从主捆绑包中拆分出的模块，则它将被重用，而不是生成新的模块
          reuseExistingChunk: true,

          // 控制此缓存组选择的模块。
          test:function(module, chunks){},

          // 仅在'initial'时才允许覆盖文件名
          filename:'',

          // 
          enforce:false
        }
      }
    }
  }
};
```

## 捆绑分析

- webpack-chart：Webpack 统计信息的交互式饼图。
- webpack-visualizer：可视化和分析您的包，以查看哪些模块占用了空间，哪些可能是重复的。
- webpack-bundle-analyzer：一个插件和 CLI 实用程序，将包内容表示为方便的交互式可缩放树形图。
- webpack 软件包优化助手：此工具将分析您的软件包，并为您提供切实可行的建议，以减少软件包的大小。
  \*bundle-stats：生成捆绑包报告（捆绑包大小，资产，模块），并比较不同版本之间的结果。  


# 自动加载

## ProvidePlugin

自动加载，而不必模块 import 或 require

```js
new webpack.ProvidePlugin({
  $: 'jquery',
  jQuery: 'jquery',
});

new webpack.ProvidePlugin({
  identifier: path.resolve(path.join(__dirname, 'src/module1')),
  // ...
});
```
